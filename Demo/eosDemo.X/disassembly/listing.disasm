Disassembly Listing for eosDemo
Generated From:
C:/Users/Rafael/Documents/Projectes/Projectes MPLAB/EOS/Demo/eosDemo.X/dist/PIC32-ETH-SK/production/eosDemo.X.production.elf
05/12/2013 19:42:20

---  c:/users/rafael/documents/projectes/projectes mplab/eos/source/sysmain.c  --------------------------
1:                   #include "eos.h"
2:                   
3:                   
4:                   #if defined(__PIC18)
5:                   extern void usrInitialize(void);
6:                   extern void usrSetup(void);
7:                   void usrTick(void);
8:                   void usrLoop(void);
9:                   #endif
10:                  
11:                  #if defined(__PIC32MX)
12:                  __attribute__((weak)) void usrInitialize(void) {
9D000980  27BDFFF8   ADDIU SP, SP, -8
9D000984  AFBE0004   SW S8, 4(SP)
9D000988  03A0F021   ADDU S8, SP, ZERO
13:                  }
9D00098C  03C0E821   ADDU SP, S8, ZERO
9D000990  8FBE0004   LW S8, 4(SP)
9D000994  27BD0008   ADDIU SP, SP, 8
9D000998  03E00008   JR RA
9D00099C  00000000   NOP
14:                  
15:                  __attribute__((weak)) void usrSetup(void) {
9D0009A0  27BDFFF8   ADDIU SP, SP, -8
9D0009A4  AFBE0004   SW S8, 4(SP)
9D0009A8  03A0F021   ADDU S8, SP, ZERO
16:                  }
9D0009AC  03C0E821   ADDU SP, S8, ZERO
9D0009B0  8FBE0004   LW S8, 4(SP)
9D0009B4  27BD0008   ADDIU SP, SP, 8
9D0009B8  03E00008   JR RA
9D0009BC  00000000   NOP
17:                  
18:                  __attribute__((weak)) void usrTick(void) {
9D0009C0  27BDFFF8   ADDIU SP, SP, -8
9D0009C4  AFBE0004   SW S8, 4(SP)
9D0009C8  03A0F021   ADDU S8, SP, ZERO
19:                  }
9D0009CC  03C0E821   ADDU SP, S8, ZERO
9D0009D0  8FBE0004   LW S8, 4(SP)
9D0009D4  27BD0008   ADDIU SP, SP, 8
9D0009D8  03E00008   JR RA
9D0009DC  00000000   NOP
20:                  
21:                  __attribute__((weak)) void usrLoop(void) {
9D0009E0  27BDFFF8   ADDIU SP, SP, -8
9D0009E4  AFBE0004   SW S8, 4(SP)
9D0009E8  03A0F021   ADDU S8, SP, ZERO
22:                     
23:                  }
9D0009EC  03C0E821   ADDU SP, S8, ZERO
9D0009F0  8FBE0004   LW S8, 4(SP)
9D0009F4  27BD0008   ADDIU SP, SP, 8
9D0009F8  03E00008   JR RA
9D0009FC  00000000   NOP
24:                  #endif
25:                  
26:                  
27:                  /*************************************************************************
28:                   *
29:                   *       Interrupcio TICK del EOS, cal cridarla cada 1ms
30:                   *
31:                   *       Funcio:
32:                   *           void eosTick(void)
33:                   *
34:                   *************************************************************************/
35:                  
36:                  void eosTick(void) {
9D000A00  27BDFFE8   ADDIU SP, SP, -24
9D000A04  AFBF0014   SW RA, 20(SP)
9D000A08  AFBE0010   SW S8, 16(SP)
9D000A0C  03A0F021   ADDU S8, SP, ZERO
37:                  
38:                  #ifdef EOS_USE_OUTPUTS
39:                      sysOutTick();
9D000A10  0F400024   JAL sysOutTick
9D000A14  00000000   NOP
40:                  #endif
41:                  
42:                  #ifdef EOS_USE_INPUTS
43:                      sysInpTick();
44:                  #endif
45:                  }
9D000A18  03C0E821   ADDU SP, S8, ZERO
9D000A1C  8FBF0014   LW RA, 20(SP)
9D000A20  8FBE0010   LW S8, 16(SP)
9D000A24  27BD0018   ADDIU SP, SP, 24
9D000A28  03E00008   JR RA
9D000A2C  00000000   NOP
46:                  
47:                  
48:                  /*************************************************************************
49:                   *
50:                   *       Interrupcio general del EOS
51:                   *
52:                   *       Funcio:
53:                   *           void eosInterrupt(void)
54:                   * 
55:                   *       Notes:
56:                   *          Per millorar el rendiment es millor cridar des de
57:                   *          l'aplicacio del usuari, a cada gestor d'interrupcio
58:                   *          individualment
59:                   *
60:                   *************************************************************************/
61:                  
62:                  void eosInterrupt(void) {
9D000A30  27BDFFE8   ADDIU SP, SP, -24
9D000A34  AFBF0014   SW RA, 20(SP)
9D000A38  AFBE0010   SW S8, 16(SP)
9D000A3C  03A0F021   ADDU S8, SP, ZERO
63:                      
64:                  #ifdef EOS_USE_OUTPUTS
65:                      sysOutInterrupt();
9D000A40  0F40005F   JAL sysOutInterrupt
9D000A44  00000000   NOP
66:                  #endif
67:                  
68:                  #ifdef EOS_USE_INPUTS
69:                      sysInpInterrupt();
70:                  #endif
71:                  }
9D000A48  03C0E821   ADDU SP, S8, ZERO
9D000A4C  8FBF0014   LW RA, 20(SP)
9D000A50  8FBE0010   LW S8, 16(SP)
9D000A54  27BD0018   ADDIU SP, SP, 24
9D000A58  03E00008   JR RA
9D000A5C  00000000   NOP
72:                  
73:                  
74:                  /*************************************************************************
75:                   *
76:                   *       Entrada a l'aplicacio. Inicialitza el sistema, i executa
77:                   *       el bucle d'usuari
78:                   *
79:                   *       Funcio:
80:                   *           void eosMain(void)
81:                   *
82:                   *************************************************************************/
83:                  
84:                  void eosMain(void) {
9D000A60  27BDFFE8   ADDIU SP, SP, -24
9D000A64  AFBF0014   SW RA, 20(SP)
9D000A68  AFBE0010   SW S8, 16(SP)
9D000A6C  03A0F021   ADDU S8, SP, ZERO
85:                  
86:                      usrInitialize();
9D000A70  0F40015A   JAL usrInitialize
9D000A74  00000000   NOP
87:                  
88:                  #ifdef EOS_USE_OUTPUTS
89:                      sysOutInitialize();
9D000A78  0F400000   JAL sysOutInitialize
9D000A7C  00000000   NOP
90:                  #endif
91:                  
92:                  #ifdef EOS_USE_INPUTS
93:                      sysInpInitialize();
94:                  #endif
95:                  
96:                  #if !defined(__DEBUG) && defined(EOS_USE_WATCHDOG)
97:                      EnableWDT();
98:                  #endif
99:                  
100:                     usrSetup();
9D000A80  0F400237   JAL usrSetup
9D000A84  00000000   NOP
101:                     while (TRUE) {
102:                 
103:                 #ifdef EOS_USE_OUTPUTS
104:                         sysOutLoop();
9D000A88  0F400067   JAL sysOutLoop
9D000A8C  00000000   NOP
105:                 #endif
106:                 
107:                 #ifdef EOS_USE_INPUTS
108:                         sysInpLoop();
109:                 #endif
110:                         usrLoop();
9D000A90  0F400240   JAL usrLoop
9D000A94  00000000   NOP
111:                 
112:                 #if !defined(__DEBUG) && defined(EOS_USE_WATCHDOG)
113:                         ClearWDT();
114:                 #endif
115:                     }
9D000A98  0B4002A2   J 0x9D000A88
9D000A9C  00000000   NOP
116:                 }
117:                  
118:                 
119:                 /*************************************************************************
120:                  *
121:                  *       Entrada a l'aplicacio desde el compilador
122:                  *
123:                  *       Funcio:
124:                  *           void main(void)
125:                  *
126:                  *************************************************************************/
127:                 
128:                 #ifdef EOS_USE_SYSMAIN
129:                 void main(void) {
9D000AA0  27BDFFE8   ADDIU SP, SP, -24
9D000AA4  AFBF0014   SW RA, 20(SP)
9D000AA8  AFBE0010   SW S8, 16(SP)
9D000AAC  03A0F021   ADDU S8, SP, ZERO
130:                 
131:                     eosMain();
9D000AB0  0F400298   JAL eosMain
9D000AB4  00000000   NOP
132:                 }
9D000AB8  03C0E821   ADDU SP, S8, ZERO
9D000ABC  8FBF0014   LW RA, 20(SP)
9D000AC0  8FBE0010   LW S8, 16(SP)
9D000AC4  27BD0018   ADDIU SP, SP, 24
9D000AC8  03E00008   JR RA
9D000ACC  00000000   NOP
133:                 #endif
---  c:/users/rafael/documents/projectes/projectes mplab/eos/source/ports/outports.c  -------------------
1:                   #include "eos.h"
2:                   
3:                   
4:                   #if defined(EOS_USE_OUTPUTS)
5:                   
6:                   
7:                   #if !defined(EOS_NUM_OUTPUTS) || (EOS_NUM_OUTPUTS < 1) || (EOS_NUM_OUTPUTS > 32)
8:                   #error 'EOS_NUM_OUTPUTS' ha de estar en el intervalo 1..16
9:                   #endif
10:                  
11:                  typedef struct {             // Estat del port
12:                      UINT16 timeout;          // -Contador de temps pels pulsos
13:                      UINT8 state:1;           // -Indica si esta actiu o no
14:                  } PORTINFO;
15:                  
16:                  static PORTINFO ports[EOS_NUM_OUTPUTS];
17:                  
18:                  
19:                  /*************************************************************************
20:                   *
21:                   *       Inicialitza la gestio de les sortides
22:                   *
23:                   *       Funcio:
24:                   *           void eosOutInitialize(void)
25:                   *
26:                   *************************************************************************/
27:                  
28:                  void sysOutInitialize(void) {
9D000000  27BDFFE0   ADDIU SP, SP, -32
9D000004  AFBF001C   SW RA, 28(SP)
9D000008  AFBE0018   SW S8, 24(SP)
9D00000C  03A0F021   ADDU S8, SP, ZERO
29:                  
30:                      __halOutInitialize();
9D000010  0F400202   JAL halOutInitialize
9D000014  00000000   NOP
31:                  
32:                      UINT8 out = EOS_NUM_OUTPUTS - 1;
9D000018  2402000F   ADDIU V0, ZERO, 15
9D00001C  A3C20010   SB V0, 16(S8)
33:                      do {
34:                          ports[out].timeout = 0;
9D000020  93C30010   LBU V1, 16(S8)
9D000024  3C02A000   LUI V0, -24576
9D000028  00031880   SLL V1, V1, 2
9D00002C  244200C4   ADDIU V0, V0, 196
9D000030  00621021   ADDU V0, V1, V0
9D000034  A4400000   SH ZERO, 0(V0)
35:                          ports[out].state = 0;
9D000038  93C30010   LBU V1, 16(S8)
9D00003C  3C02A000   LUI V0, -24576
9D000040  00031880   SLL V1, V1, 2
9D000044  244200C4   ADDIU V0, V0, 196
9D000048  00621821   ADDU V1, V1, V0
9D00004C  8C620000   LW V0, 0(V1)
9D000050  7C028404   INS V0, ZERO, 16, 1
9D000054  AC620000   SW V0, 0(V1)
36:                      } while (out--);
9D000058  93C20010   LBU V0, 16(S8)
9D00005C  0002102B   SLTU V0, ZERO, V0
9D000060  304200FF   ANDI V0, V0, 255
9D000064  93C30010   LBU V1, 16(S8)
9D000068  2463FFFF   ADDIU V1, V1, -1
9D00006C  A3C30010   SB V1, 16(S8)
9D000070  1440FFEB   BNE V0, ZERO, 0x9D000020
9D000074  00000000   NOP
37:                  }
9D000078  03C0E821   ADDU SP, S8, ZERO
9D00007C  8FBF001C   LW RA, 28(SP)
9D000080  8FBE0018   LW S8, 24(SP)
9D000084  27BD0020   ADDIU SP, SP, 32
9D000088  03E00008   JR RA
9D00008C  00000000   NOP
38:                  
39:                  
40:                  /*************************************************************************
41:                   *
42:                   *       Tasca de control de les sortides. Es crida cada 1ms
43:                   *
44:                   *       Funcio:
45:                   *           void eosOutTick(void)
46:                   *
47:                   *************************************************************************/
48:                  
49:                  void sysOutTick(void) {
9D000090  27BDFFF0   ADDIU SP, SP, -16
9D000094  AFBE000C   SW S8, 12(SP)
9D000098  03A0F021   ADDU S8, SP, ZERO
50:                  
51:                      // Actualitza les sortides temporitzades
52:                      //
53:                      UINT8 out = EOS_NUM_OUTPUTS - 1;
9D00009C  2402000F   ADDIU V0, ZERO, 15
9D0000A0  A3C20000   SB V0, 0(S8)
54:                      do {
55:                          UINT16 to = ports[out].timeout;
9D0000A4  93C30000   LBU V1, 0(S8)
9D0000A8  3C02A000   LUI V0, -24576
9D0000AC  00031880   SLL V1, V1, 2
9D0000B0  244200C4   ADDIU V0, V0, 196
9D0000B4  00621021   ADDU V0, V1, V0
9D0000B8  94420000   LHU V0, 0(V0)
9D0000BC  A7C20002   SH V0, 2(S8)
56:                          if (to != 0) {
9D0000C0  97C20002   LHU V0, 2(S8)
9D0000C4  10400020   BEQ V0, ZERO, 0x9D000148
9D0000C8  00000000   NOP
57:                              to -= 1;
9D0000CC  97C20002   LHU V0, 2(S8)
9D0000D0  2442FFFF   ADDIU V0, V0, -1
9D0000D4  A7C20002   SH V0, 2(S8)
58:                              if (to == 0)
9D0000D8  97C20002   LHU V0, 2(S8)
9D0000DC  14400013   BNE V0, ZERO, 0x9D00012C
9D0000E0  00000000   NOP
59:                                  ports[out].state = !ports[out].state;
9D0000E4  93C30000   LBU V1, 0(S8)
9D0000E8  93C40000   LBU A0, 0(S8)
9D0000EC  3C02A000   LUI V0, -24576
9D0000F0  00042080   SLL A0, A0, 2
9D0000F4  244200C4   ADDIU V0, V0, 196
9D0000F8  00821021   ADDU V0, A0, V0
9D0000FC  8C420000   LW V0, 0(V0)
9D000100  7C420400   EXT V0, V0, 16, 1
9D000104  304200FF   ANDI V0, V0, 255
9D000108  2C420001   SLTIU V0, V0, 1
9D00010C  304400FF   ANDI A0, V0, 255
9D000110  3C02A000   LUI V0, -24576
9D000114  00031880   SLL V1, V1, 2
9D000118  244200C4   ADDIU V0, V0, 196
9D00011C  00621821   ADDU V1, V1, V0
9D000120  8C620000   LW V0, 0(V1)
9D000124  7C828404   INS V0, A0, 16, 1
9D000128  AC620000   SW V0, 0(V1)
60:                              ports[out].timeout = to;
9D00012C  93C30000   LBU V1, 0(S8)
9D000130  3C02A000   LUI V0, -24576
9D000134  00031880   SLL V1, V1, 2
9D000138  244200C4   ADDIU V0, V0, 196
9D00013C  00621021   ADDU V0, V1, V0
9D000140  97C30002   LHU V1, 2(S8)
9D000144  A4430000   SH V1, 0(V0)
61:                          }
62:                      } while (out--);
9D000148  93C20000   LBU V0, 0(S8)
9D00014C  0002102B   SLTU V0, ZERO, V0
9D000150  304200FF   ANDI V0, V0, 255
9D000154  93C30000   LBU V1, 0(S8)
9D000158  2463FFFF   ADDIU V1, V1, -1
9D00015C  A3C30000   SB V1, 0(S8)
9D000160  1440FFD0   BNE V0, ZERO, 0x9D0000A4
9D000164  00000000   NOP
63:                  }
9D000168  03C0E821   ADDU SP, S8, ZERO
9D00016C  8FBE000C   LW S8, 12(SP)
9D000170  27BD0010   ADDIU SP, SP, 16
9D000174  03E00008   JR RA
9D000178  00000000   NOP
64:                  
65:                  
66:                  /*************************************************************************
67:                   *
68:                   *       Procesa les interrupcions del modul
69:                   *
70:                   *       Funcio:
71:                   *           void sysOutInterrupt(void)
72:                   *
73:                   *************************************************************************/
74:                  
75:                  void sysOutInterrupt(void){
9D00017C  27BDFFF8   ADDIU SP, SP, -8
9D000180  AFBE0004   SW S8, 4(SP)
9D000184  03A0F021   ADDU S8, SP, ZERO
76:                  
77:                  }
9D000188  03C0E821   ADDU SP, S8, ZERO
9D00018C  8FBE0004   LW S8, 4(SP)
9D000190  27BD0008   ADDIU SP, SP, 8
9D000194  03E00008   JR RA
9D000198  00000000   NOP
78:                  
79:                  
80:                  /*************************************************************************
81:                   *
82:                   *       Tasca de control de les sortides. Es crida en cada cicle
83:                   *
84:                   *       Funcio:
85:                   *           void eosOutLoop(void)
86:                   *
87:                   *************************************************************************/
88:                  
89:                  void sysOutLoop(void){
9D00019C  27BDFFE0   ADDIU SP, SP, -32
9D0001A0  AFBF001C   SW RA, 28(SP)
9D0001A4  AFBE0018   SW S8, 24(SP)
9D0001A8  03A0F021   ADDU S8, SP, ZERO
90:                  
91:                      eosDisableInterrupts();
9D0001AC  0F400394   JAL INTDisableInterrupts
9D0001B0  00000000   NOP
92:                      
93:                      UINT8 out = EOS_NUM_OUTPUTS - 1;
9D0001B4  2402000F   ADDIU V0, ZERO, 15
9D0001B8  A3C20010   SB V0, 16(S8)
94:                      do {
95:                        __halOutWrite(out, ports[out].state);
9D0001BC  93C30010   LBU V1, 16(S8)
9D0001C0  93C40010   LBU A0, 16(S8)
9D0001C4  3C02A000   LUI V0, -24576
9D0001C8  00042080   SLL A0, A0, 2
9D0001CC  244200C4   ADDIU V0, V0, 196
9D0001D0  00821021   ADDU V0, A0, V0
9D0001D4  8C420000   LW V0, 0(V0)
9D0001D8  7C420400   EXT V0, V0, 16, 1
9D0001DC  304200FF   ANDI V0, V0, 255
9D0001E0  00602021   ADDU A0, V1, ZERO
9D0001E4  00402821   ADDU A1, V0, ZERO
9D0001E8  0F40020F   JAL halOutWrite
9D0001EC  00000000   NOP
96:                      } while (out--);
9D0001F0  93C20010   LBU V0, 16(S8)
9D0001F4  0002102B   SLTU V0, ZERO, V0
9D0001F8  304200FF   ANDI V0, V0, 255
9D0001FC  93C30010   LBU V1, 16(S8)
9D000200  2463FFFF   ADDIU V1, V1, -1
9D000204  A3C30010   SB V1, 16(S8)
9D000208  1440FFEC   BNE V0, ZERO, 0x9D0001BC
9D00020C  00000000   NOP
97:                      
98:                      eosEnableInterrupts();
9D000210  0F400392   JAL INTEnableInterrupts
9D000214  00000000   NOP
99:                  }
9D000218  03C0E821   ADDU SP, S8, ZERO
9D00021C  8FBF001C   LW RA, 28(SP)
9D000220  8FBE0018   LW S8, 24(SP)
9D000224  27BD0020   ADDIU SP, SP, 32
9D000228  03E00008   JR RA
9D00022C  00000000   NOP
100:                 
101:                 
102:                 /*************************************************************************
103:                  *
104:                  *       Asigna l'estat a una sortida
105:                  *
106:                  *       Funcio:
107:                  *           void eosOutSet(UINT8 out, BOOL s)
108:                  *
109:                  *       Entrada:
110:                  *           out: Numero de sortida
111:                  *           s  : El nou estat a asignar
112:                  *
113:                  *************************************************************************/
114:                 
115:                 void eosOutSet(UINT8 out, BOOL s) {
9D000230  27BDFFE8   ADDIU SP, SP, -24
9D000234  AFBF0014   SW RA, 20(SP)
9D000238  AFBE0010   SW S8, 16(SP)
9D00023C  03A0F021   ADDU S8, SP, ZERO
9D000240  00801021   ADDU V0, A0, ZERO
9D000244  AFC5001C   SW A1, 28(S8)
9D000248  A3C20018   SB V0, 24(S8)
116:                 
117:                     if (out < EOS_NUM_OUTPUTS) {
9D00024C  93C20018   LBU V0, 24(S8)
9D000250  2C420010   SLTIU V0, V0, 16
9D000254  10400017   BEQ V0, ZERO, 0x9D0002B4
9D000258  00000000   NOP
118:                         eosDisableInterrupts();
9D00025C  0F400394   JAL INTDisableInterrupts
9D000260  00000000   NOP
119:                         ports[out].state = s;
9D000264  93C30018   LBU V1, 24(S8)
9D000268  8FC2001C   LW V0, 28(S8)
9D00026C  304200FF   ANDI V0, V0, 255
9D000270  30420001   ANDI V0, V0, 1
9D000274  304400FF   ANDI A0, V0, 255
9D000278  3C02A000   LUI V0, -24576
9D00027C  00031880   SLL V1, V1, 2
9D000280  244200C4   ADDIU V0, V0, 196
9D000284  00621821   ADDU V1, V1, V0
9D000288  8C620000   LW V0, 0(V1)
9D00028C  7C828404   INS V0, A0, 16, 1
9D000290  AC620000   SW V0, 0(V1)
120:                         ports[out].timeout  = 0;
9D000294  93C30018   LBU V1, 24(S8)
9D000298  3C02A000   LUI V0, -24576
9D00029C  00031880   SLL V1, V1, 2
9D0002A0  244200C4   ADDIU V0, V0, 196
9D0002A4  00621021   ADDU V0, V1, V0
9D0002A8  A4400000   SH ZERO, 0(V0)
121:                         eosEnableInterrupts();
9D0002AC  0F400392   JAL INTEnableInterrupts
9D0002B0  00000000   NOP
122:                     }
123:                 }
9D0002B4  03C0E821   ADDU SP, S8, ZERO
9D0002B8  8FBF0014   LW RA, 20(SP)
9D0002BC  8FBE0010   LW S8, 16(SP)
9D0002C0  27BD0018   ADDIU SP, SP, 24
9D0002C4  03E00008   JR RA
9D0002C8  00000000   NOP
124:                 
125:                 
126:                 /*************************************************************************
127:                  *
128:                  *       Llegeix l'estat d'una sortida
129:                  *
130:                  *       Funcio:
131:                  *           BOOL eosOutGet(UINT8 out)
132:                  *
133:                  *       Entrada:
134:                  *           out: Numero de sortida
135:                  *
136:                  *       Retorn:
137:                  *           L'estat de la sortida
138:                  *
139:                  *************************************************************************/
140:                 
141:                 BOOL eosOutGet(UINT8 out) {
9D0002CC  27BDFFE0   ADDIU SP, SP, -32
9D0002D0  AFBF001C   SW RA, 28(SP)
9D0002D4  AFBE0018   SW S8, 24(SP)
9D0002D8  03A0F021   ADDU S8, SP, ZERO
9D0002DC  00801021   ADDU V0, A0, ZERO
9D0002E0  A3C20020   SB V0, 32(S8)
142:                 
143:                     if (out < EOS_NUM_OUTPUTS) {
9D0002E4  93C20020   LBU V0, 32(S8)
9D0002E8  2C420010   SLTIU V0, V0, 16
9D0002EC  10400011   BEQ V0, ZERO, 0x9D000334
9D0002F0  00000000   NOP
144:                         eosDisableInterrupts();
9D0002F4  0F400394   JAL INTDisableInterrupts
9D0002F8  00000000   NOP
145:                         BOOL result = ports[out].state;
9D0002FC  93C30020   LBU V1, 32(S8)
9D000300  3C02A000   LUI V0, -24576
9D000304  00031880   SLL V1, V1, 2
9D000308  244200C4   ADDIU V0, V0, 196
9D00030C  00621021   ADDU V0, V1, V0
9D000310  8C420000   LW V0, 0(V0)
9D000314  7C420400   EXT V0, V0, 16, 1
9D000318  304200FF   ANDI V0, V0, 255
9D00031C  AFC20010   SW V0, 16(S8)
146:                         eosEnableInterrupts();
9D000320  0F400392   JAL INTEnableInterrupts
9D000324  00000000   NOP
147:                         return result;
9D000328  8FC20010   LW V0, 16(S8)
9D00032C  0B4000CE   J 0x9D000338
9D000330  00000000   NOP
148:                     }
149:                     else
150:                         return FALSE;
9D000334  00001021   ADDU V0, ZERO, ZERO
151:                 }
9D000338  03C0E821   ADDU SP, S8, ZERO
9D00033C  8FBF001C   LW RA, 28(SP)
9D000340  8FBE0018   LW S8, 24(SP)
9D000344  27BD0020   ADDIU SP, SP, 32
9D000348  03E00008   JR RA
9D00034C  00000000   NOP
152:                 
153:                 
154:                 /*************************************************************************
155:                  *
156:                  *       Genera un puls
157:                  *
158:                  *       Funcio:
159:                  *           void eosOutPulse(UINT8 out, UINT16 time)
160:                  *
161:                  *       Entrada:
162:                  *           out : Numero de sortida
163:                  *           time: Llargada del puls en ms
164:                  *
165:                  *       Notes:
166:                  *           Si el puls encara es actiu, simplement l'allarga el temps
167:                  *           especificat
168:                  *
169:                  *************************************************************************/
170:                 
171:                 void eosOutPulse(UINT8 out, UINT16 time) {
9D000350  27BDFFE8   ADDIU SP, SP, -24
9D000354  AFBF0014   SW RA, 20(SP)
9D000358  AFBE0010   SW S8, 16(SP)
9D00035C  03A0F021   ADDU S8, SP, ZERO
9D000360  00801821   ADDU V1, A0, ZERO
9D000364  00A01021   ADDU V0, A1, ZERO
9D000368  A3C30018   SB V1, 24(S8)
9D00036C  A7C2001C   SH V0, 28(S8)
172:                 
173:                     if ((out < EOS_NUM_OUTPUTS) && (time != 0)) {
9D000370  93C20018   LBU V0, 24(S8)
9D000374  2C420010   SLTIU V0, V0, 16
9D000378  10400029   BEQ V0, ZERO, 0x9D000420
9D00037C  00000000   NOP
9D000380  97C2001C   LHU V0, 28(S8)
9D000384  10400026   BEQ V0, ZERO, 0x9D000420
9D000388  00000000   NOP
174:                         eosDisableInterrupts();
9D00038C  0F400394   JAL INTDisableInterrupts
9D000390  00000000   NOP
175:                         if (ports[out].timeout == 0) {
9D000394  93C30018   LBU V1, 24(S8)
9D000398  3C02A000   LUI V0, -24576
9D00039C  00031880   SLL V1, V1, 2
9D0003A0  244200C4   ADDIU V0, V0, 196
9D0003A4  00621021   ADDU V0, V1, V0
9D0003A8  94420000   LHU V0, 0(V0)
9D0003AC  14400013   BNE V0, ZERO, 0x9D0003FC
9D0003B0  00000000   NOP
176:                             ports[out].state = !ports[out].state;
9D0003B4  93C30018   LBU V1, 24(S8)
9D0003B8  93C40018   LBU A0, 24(S8)
9D0003BC  3C02A000   LUI V0, -24576
9D0003C0  00042080   SLL A0, A0, 2
9D0003C4  244200C4   ADDIU V0, V0, 196
9D0003C8  00821021   ADDU V0, A0, V0
9D0003CC  8C420000   LW V0, 0(V0)
9D0003D0  7C420400   EXT V0, V0, 16, 1
9D0003D4  304200FF   ANDI V0, V0, 255
9D0003D8  2C420001   SLTIU V0, V0, 1
9D0003DC  304400FF   ANDI A0, V0, 255
9D0003E0  3C02A000   LUI V0, -24576
9D0003E4  00031880   SLL V1, V1, 2
9D0003E8  244200C4   ADDIU V0, V0, 196
9D0003EC  00621821   ADDU V1, V1, V0
9D0003F0  8C620000   LW V0, 0(V1)
9D0003F4  7C828404   INS V0, A0, 16, 1
9D0003F8  AC620000   SW V0, 0(V1)
177:                         }
178:                         ports[out].timeout = time;
9D0003FC  93C30018   LBU V1, 24(S8)
9D000400  3C02A000   LUI V0, -24576
9D000404  00031880   SLL V1, V1, 2
9D000408  244200C4   ADDIU V0, V0, 196
9D00040C  00621021   ADDU V0, V1, V0
9D000410  97C3001C   LHU V1, 28(S8)
9D000414  A4430000   SH V1, 0(V0)
179:                         eosEnableInterrupts();
9D000418  0F400392   JAL INTEnableInterrupts
9D00041C  00000000   NOP
180:                     }
181:                 }
9D000420  03C0E821   ADDU SP, S8, ZERO
9D000424  8FBF0014   LW RA, 20(SP)
9D000428  8FBE0010   LW S8, 16(SP)
9D00042C  27BD0018   ADDIU SP, SP, 24
9D000430  03E00008   JR RA
9D000434  00000000   NOP
182:                 
183:                 
184:                 /*************************************************************************
185:                  *
186:                  *       Inverteix l'estat d'una sortida
187:                  *
188:                  *       Funcio:
189:                  *           void eosOutToggle(UINT8 out)
190:                  *
191:                  *       Entrada:
192:                  *           out: El numero de sortida
193:                  *
194:                  *************************************************************************/
195:                 
196:                 void eosOutToggle(UINT8 out) {
9D000438  27BDFFE8   ADDIU SP, SP, -24
9D00043C  AFBF0014   SW RA, 20(SP)
9D000440  AFBE0010   SW S8, 16(SP)
9D000444  03A0F021   ADDU S8, SP, ZERO
9D000448  00801021   ADDU V0, A0, ZERO
9D00044C  A3C20018   SB V0, 24(S8)
197:                 
198:                     if (out < EOS_NUM_OUTPUTS) {
9D000450  93C20018   LBU V0, 24(S8)
9D000454  2C420010   SLTIU V0, V0, 16
9D000458  1040001D   BEQ V0, ZERO, 0x9D0004D0
9D00045C  00000000   NOP
199:                         eosDisableInterrupts();
9D000460  0F400394   JAL INTDisableInterrupts
9D000464  00000000   NOP
200:                         ports[out].state = !ports[out].state;
9D000468  93C30018   LBU V1, 24(S8)
9D00046C  93C40018   LBU A0, 24(S8)
9D000470  3C02A000   LUI V0, -24576
9D000474  00042080   SLL A0, A0, 2
9D000478  244200C4   ADDIU V0, V0, 196
9D00047C  00821021   ADDU V0, A0, V0
9D000480  8C420000   LW V0, 0(V0)
9D000484  7C420400   EXT V0, V0, 16, 1
9D000488  304200FF   ANDI V0, V0, 255
9D00048C  2C420001   SLTIU V0, V0, 1
9D000490  304400FF   ANDI A0, V0, 255
9D000494  3C02A000   LUI V0, -24576
9D000498  00031880   SLL V1, V1, 2
9D00049C  244200C4   ADDIU V0, V0, 196
9D0004A0  00621821   ADDU V1, V1, V0
9D0004A4  8C620000   LW V0, 0(V1)
9D0004A8  7C828404   INS V0, A0, 16, 1
9D0004AC  AC620000   SW V0, 0(V1)
201:                         ports[out].timeout = 0;
9D0004B0  93C30018   LBU V1, 24(S8)
9D0004B4  3C02A000   LUI V0, -24576
9D0004B8  00031880   SLL V1, V1, 2
9D0004BC  244200C4   ADDIU V0, V0, 196
9D0004C0  00621021   ADDU V0, V1, V0
9D0004C4  A4400000   SH ZERO, 0(V0)
202:                         eosEnableInterrupts();
9D0004C8  0F400392   JAL INTEnableInterrupts
9D0004CC  00000000   NOP
203:                     }
204:                 }
9D0004D0  03C0E821   ADDU SP, S8, ZERO
9D0004D4  8FBF0014   LW RA, 20(SP)
9D0004D8  8FBE0010   LW S8, 16(SP)
9D0004DC  27BD0018   ADDIU SP, SP, 24
9D0004E0  03E00008   JR RA
9D0004E4  00000000   NOP
205:                 
206:                 
207:                 /*************************************************************************
208:                  *
209:                  *       Posa totes les sortides a OFF
210:                  *
211:                  *       Funcio:
212:                  *           void eosOutAllOFF(void)
213:                  *
214:                  *************************************************************************/
215:                 
216:                 void eosOutAllOFF(void) {
9D0004E8  27BDFFF0   ADDIU SP, SP, -16
9D0004EC  AFBE000C   SW S8, 12(SP)
9D0004F0  03A0F021   ADDU S8, SP, ZERO
217:                 
218:                     UINT8 out = EOS_NUM_OUTPUTS - 1;
9D0004F4  2402000F   ADDIU V0, ZERO, 15
9D0004F8  A3C20000   SB V0, 0(S8)
219:                     do {
220:                         ports[out].state = 0;
9D0004FC  93C30000   LBU V1, 0(S8)
9D000500  3C02A000   LUI V0, -24576
9D000504  00031880   SLL V1, V1, 2
9D000508  244200C4   ADDIU V0, V0, 196
9D00050C  00621821   ADDU V1, V1, V0
9D000510  8C620000   LW V0, 0(V1)
9D000514  7C028404   INS V0, ZERO, 16, 1
9D000518  AC620000   SW V0, 0(V1)
221:                         ports[out].timeout = 0;
9D00051C  93C30000   LBU V1, 0(S8)
9D000520  3C02A000   LUI V0, -24576
9D000524  00031880   SLL V1, V1, 2
9D000528  244200C4   ADDIU V0, V0, 196
9D00052C  00621021   ADDU V0, V1, V0
9D000530  A4400000   SH ZERO, 0(V0)
222:                     } while (out--);
9D000534  93C20000   LBU V0, 0(S8)
9D000538  0002102B   SLTU V0, ZERO, V0
9D00053C  304200FF   ANDI V0, V0, 255
9D000540  93C30000   LBU V1, 0(S8)
9D000544  2463FFFF   ADDIU V1, V1, -1
9D000548  A3C30000   SB V1, 0(S8)
9D00054C  1440FFEB   BNE V0, ZERO, 0x9D0004FC
9D000550  00000000   NOP
223:                 }
9D000554  03C0E821   ADDU SP, S8, ZERO
9D000558  8FBE000C   LW S8, 12(SP)
9D00055C  27BD0010   ADDIU SP, SP, 16
9D000560  03E00008   JR RA
9D000564  00000000   NOP
224:                 
225:                 
226:                 #endif
---  c:/users/rafael/documents/projectes/projectes mplab/eos/demo/main.c  -------------------------------
1:                   #include "eos.h"
2:                   
3:                   
4:                   /*************************************************************************
5:                    *
6:                    *       Inicialitza el hardware
7:                    *
8:                    *       Funcio:
9:                    *           void usrInitialize(void) 
10:                   *
11:                   **************************************************************************/
12:                  
13:                  #if defined(_12F1822) || defined(_16F1823) || defined(_16F1825) || defined(_16F1829)
14:                  void usrInitialize(void) {
15:                  
16:                      // Configuracio del oscilador (Fosc = 32MHz)
17:                      // -Oscilador intern HS a 8MHz
18:                      // -PLL x4 --> 8MHz x 4 = 32MHz
19:                      // -Oscilador primari seleccionat en CONFIG
20:                      //
21:                      OSCCONbits.SPLLEN = 1;        // Activa PLLx4 (Esta OFF en CONFIG2)
22:                      OSCCONbits.SCS = 0;           // Oscilador primari en CONFIG.FOSC
23:                      OSCCONbits.IRCF = 0x0E;       // 8MHz a la entrada del PLL
24:                  
25:                      // Espera que s'estabilitzi l'oscilador
26:                      //
27:                      while (!OSCSTATbits.HFIOFS)
28:                          continue;
29:                  }
30:                  
31:                  #elif defined(_18F23K22) || defined(_18F24K22) || defined(_18F25K22) || defined(_18F26K22) || \
32:                        defined(_18F43K22) || defined(_18F44K22) || defined(_18F45K22) || defined(_18F46K22)
33:                  void usrInitialize(void) {
34:                  
35:                      // Configuracio del oscilador (Fosc = 64MHz)
36:                      // -Oscilador intern HS a 16MHz
37:                      // -PLL x4 --> 16MHz x 4 = 64MHz
38:                      // -Oscilador primari seleccionat en CONFIG
39:                      //
40:                  #ifdef __DEBUG
41:                      OSCCONbits.SCS = 0;           // Oscilador primari en CONFIG.FOSC
42:                  #else
43:                      OSCTUNEbits.PLLEN = 1;        // PLL enabled (x4)
44:                      OSCCONbits.IRCF = 7;          // 16MHz en HFINTOSC
45:                      OSCTUNEbits.INTSRC = 1;       // 31.25 clock from HS
46:                      OSCCONbits.SCS = 0;           // Oscilador primari en CONFIG.FOSC
47:                  
48:                      // Espera que s'estabilitzi l'oscilador
49:                      //
50:                  #ifdef USE_OSC_INTERNAL
51:                      while (!OSCCONbits.HFIOFS)
52:                          continue;
53:                  #endif
54:                  #endif
55:                  }
56:                  
57:                  #elif defined(__PIC32MX)
58:                  void usrInitialize(void) {
9D000568  27BDFFA0   ADDIU SP, SP, -96
9D00056C  AFBF005C   SW RA, 92(SP)
9D000570  AFBE0058   SW S8, 88(SP)
9D000574  03A0F021   ADDU S8, SP, ZERO
9D000578  3C0204C4   LUI V0, 1220
9D00057C  3442B400   ORI V0, V0, -19456
9D000580  AFC20010   SW V0, 16(S8)
9D000584  8FC20010   LW V0, 16(S8)
9D000588  AFC20014   SW V0, 20(S8)
9D00058C  8FC20014   LW V0, 20(S8)
9D000590  AFC20018   SW V0, 24(S8)
59:                  
60:                      SYSTEMConfigPerformance(GetSystemClock());
61:                      INTConfigureSystem(INT_SYSTEM_CONFIG_MULT_VECTOR);
9D0007E4  00002021   ADDU A0, ZERO, ZERO
9D0007E8  0F400367   JAL INTConfigureSystem
9D0007EC  00000000   NOP
62:                  }
9D0007F0  03C0E821   ADDU SP, S8, ZERO
9D0007F4  8FBF005C   LW RA, 92(SP)
9D0007F8  8FBE0058   LW S8, 88(SP)
9D0007FC  27BD0060   ADDIU SP, SP, 96
9D000800  03E00008   JR RA
9D000804  00000000   NOP
63:                  
64:                  #else
65:                  #error Hardware no soportado
66:                  #endif
67:                  
68:                  void halOutInitialize(void) {
9D000808  27BDFFF8   ADDIU SP, SP, -8
9D00080C  AFBE0004   SW S8, 4(SP)
9D000810  03A0F021   ADDU S8, SP, ZERO
69:                  
70:                      PORTDCLR = 0b0000000000000000;
9D000814  3C02BF88   LUI V0, -16504
9D000818  AC4060D4   SW ZERO, 24788(V0)
71:                      TRISDCLR = 0b0000000000000111;
9D00081C  3C02BF88   LUI V0, -16504
9D000820  24030007   ADDIU V1, ZERO, 7
9D000824  AC4360C4   SW V1, 24772(V0)
72:                  }
9D000828  03C0E821   ADDU SP, S8, ZERO
9D00082C  8FBE0004   LW S8, 4(SP)
9D000830  27BD0008   ADDIU SP, SP, 8
9D000834  03E00008   JR RA
9D000838  00000000   NOP
73:                  
74:                  volatile unsigned int *portSet[EOS_NUM_OUTPUTS] = {
75:                      &PORTDSET,
76:                      &PORTDSET,
77:                      &PORTDSET,
78:                      0,0,0,0,0,0,0,0,0,0,0,0,0
79:                  };
80:                  
81:                  volatile unsigned int *portClr[EOS_NUM_OUTPUTS] = {
82:                      &PORTDCLR,
83:                      &PORTDCLR,
84:                      &PORTDCLR,
85:                      0,0,0,0,0,0,0,0,0,0,0,0,0
86:                  };
87:                  
88:                  volatile unsigned int portBit[EOS_NUM_OUTPUTS] = {
89:                      1,
90:                      2,
91:                      4,
92:                      0,0,0,0,0,0,0,0,0,0,0,0,0
93:                  };
94:                  
95:                  void halOutWrite(UINT8 out, BOOL s) {
9D00083C  27BDFFF0   ADDIU SP, SP, -16
9D000840  AFBE000C   SW S8, 12(SP)
9D000844  03A0F021   ADDU S8, SP, ZERO
9D000848  00801021   ADDU V0, A0, ZERO
9D00084C  AFC50014   SW A1, 20(S8)
9D000850  A3C20010   SB V0, 16(S8)
96:                  
97:                      volatile unsigned int *p = s ? portSet[out] : portClr[out];
9D000854  8FC20014   LW V0, 20(S8)
9D000858  10400009   BEQ V0, ZERO, 0x9D000880
9D00085C  00000000   NOP
9D000860  93C30010   LBU V1, 16(S8)
9D000864  3C02A000   LUI V0, -24576
9D000868  00031880   SLL V1, V1, 2
9D00086C  24420004   ADDIU V0, V0, 4
9D000870  00621021   ADDU V0, V1, V0
9D000874  8C420000   LW V0, 0(V0)
9D000878  0B400226   J 0x9D000898
9D00087C  00000000   NOP
9D000880  93C30010   LBU V1, 16(S8)
9D000884  3C02A000   LUI V0, -24576
9D000888  00031880   SLL V1, V1, 2
9D00088C  24420044   ADDIU V0, V0, 68
9D000890  00621021   ADDU V0, V1, V0
9D000894  8C420000   LW V0, 0(V0)
9D000898  AFC20000   SW V0, 0(S8)
98:                      if (p)
9D00089C  8FC20000   LW V0, 0(S8)
9D0008A0  10400009   BEQ V0, ZERO, 0x9D0008C8
9D0008A4  00000000   NOP
99:                          *p = portBit[out];
9D0008A8  93C30010   LBU V1, 16(S8)
9D0008AC  3C02A000   LUI V0, -24576
9D0008B0  00031880   SLL V1, V1, 2
9D0008B4  24420084   ADDIU V0, V0, 132
9D0008B8  00621021   ADDU V0, V1, V0
9D0008BC  8C430000   LW V1, 0(V0)
9D0008C0  8FC20000   LW V0, 0(S8)
9D0008C4  AC430000   SW V1, 0(V0)
100:                 }
9D0008C8  03C0E821   ADDU SP, S8, ZERO
9D0008CC  8FBE000C   LW S8, 12(SP)
9D0008D0  27BD0010   ADDIU SP, SP, 16
9D0008D4  03E00008   JR RA
9D0008D8  00000000   NOP
101:                 
102:                 
103:                 static UINT16 x;
104:                 
105:                 void usrSetup(void) {
9D0008DC  27BDFFF8   ADDIU SP, SP, -8
9D0008E0  AFBE0004   SW S8, 4(SP)
9D0008E4  03A0F021   ADDU S8, SP, ZERO
106:                 
107:                     x = 0;
9D0008E8  A7808010   SH ZERO, -32752(GP)
108:                 }
9D0008EC  03C0E821   ADDU SP, S8, ZERO
9D0008F0  8FBE0004   LW S8, 4(SP)
9D0008F4  27BD0008   ADDIU SP, SP, 8
9D0008F8  03E00008   JR RA
9D0008FC  00000000   NOP
109:                 
110:                 void usrLoop(void) {
9D000900  27BDFFE8   ADDIU SP, SP, -24
9D000904  AFBF0014   SW RA, 20(SP)
9D000908  AFBE0010   SW S8, 16(SP)
9D00090C  03A0F021   ADDU S8, SP, ZERO
111:                 
112:                     eosOutSet(0, x < 100);
9D000910  97828010   LHU V0, -32752(GP)
9D000914  2C420064   SLTIU V0, V0, 100
9D000918  00002021   ADDU A0, ZERO, ZERO
9D00091C  00402821   ADDU A1, V0, ZERO
9D000920  0F40008C   JAL eosOutSet
9D000924  00000000   NOP
113:                     eosOutSet(1, x > 400);
9D000928  97828010   LHU V0, -32752(GP)
9D00092C  2C420191   SLTIU V0, V0, 401
9D000930  38420001   XORI V0, V0, 1
9D000934  24040001   ADDIU A0, ZERO, 1
9D000938  00402821   ADDU A1, V0, ZERO
9D00093C  0F40008C   JAL eosOutSet
9D000940  00000000   NOP
114:                 
115:                     x++;
9D000944  97828010   LHU V0, -32752(GP)
9D000948  24420001   ADDIU V0, V0, 1
9D00094C  3042FFFF   ANDI V0, V0, -1
9D000950  A7828010   SH V0, -32752(GP)
116:                     if (x > 1000)
9D000954  97828010   LHU V0, -32752(GP)
9D000958  2C4203E9   SLTIU V0, V0, 1001
9D00095C  14400002   BNE V0, ZERO, 0x9D000968
9D000960  00000000   NOP
117:                         x = 0;
9D000964  A7808010   SH ZERO, -32752(GP)
118:                 }
9D000968  03C0E821   ADDU SP, S8, ZERO
9D00096C  8FBF0014   LW RA, 20(SP)
9D000970  8FBE0010   LW S8, 16(SP)
9D000974  27BD0018   ADDIU SP, SP, 24
9D000978  03E00008   JR RA
9D00097C  00000000   NOP
---  c:/program files/microchip/xc32/v1.30/pic32mx/include/peripheral/system.h  -------------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the ?Company?) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company?s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
67:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
68:                  
69:                  /*********************************************************************
70:                   * SYSTEMConfig Flags
71:                   *********************************************************************/
72:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
73:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
74:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
75:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
76:                  
77:                  /*********************************************************************
78:                   Function:       
79:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
80:                   
81:                   Description:
82:                  	The function sets the PB divider to the optimum value.
83:                   
84:                   PreCondition:    
85:                  	None
86:                   
87:                   Parameters:           
88:                  	sys_clock - system clock in Hz
89:                   
90:                   Returns:          
91:                  	the PB clock frequency in Hz
92:                   
93:                   Side Effects:
94:                  	The PB clock may be changed
95:                  	
96:                   Overview:	    
97:                  	The function sets the PB divider to the optimum value.
98:                   
99:                   Remarks:            
100:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
101:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
102:                  
103:                  Example:
104:                 	<code>
105:                 	SYSTEMConfigPB(72000000);
106:                 	</code>
107:                  ********************************************************************/
108:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
109:                 {
110:                     unsigned int pb_div;
111:                     unsigned int pb_clock;
112:                 
113:                     pb_clock = sys_clock;
9D000594  8FC20018   LW V0, 24(S8)
9D000598  AFC2001C   SW V0, 28(S8)
114:                 
115:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D00059C  8FC30018   LW V1, 24(S8)
9D0005A0  3C0204C4   LUI V0, 1220
9D0005A4  3442B401   ORI V0, V0, -19455
9D0005A8  0062102B   SLTU V0, V1, V0
9D0005AC  14400008   BNE V0, ZERO, 0x9D0005D0
9D0005B0  00000000   NOP
116:                     {
117:                         pb_div=OSC_PB_DIV_2;
9D0005B4  3C020008   LUI V0, 8
9D0005B8  AFC20020   SW V0, 32(S8)
118:                         pb_clock >>= 1;
9D0005BC  8FC2001C   LW V0, 28(S8)
9D0005C0  00021042   SRL V0, V0, 1
9D0005C4  AFC2001C   SW V0, 28(S8)
9D0005C8  0B400175   J 0x9D0005D4
9D0005CC  00000000   NOP
119:                     }
120:                     else
121:                     {
122:                         pb_div=OSC_PB_DIV_1;
9D0005D0  AFC00020   SW ZERO, 32(S8)
9D0005D4  8FC20020   LW V0, 32(S8)
9D0005D8  AFC20024   SW V0, 36(S8)
123:                     }
124:                 
125:                     OSCSetPBDIV(pb_div);
126:                 
127:                     return pb_clock;
9D00071C  8FC2001C   LW V0, 28(S8)
128:                 }
129:                 
130:                 
131:                 /*********************************************************************
132:                   Function:        
133:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
134:                  
135:                   Description:
136:                 	The function sets the Flash Wait states to the optimum value.
137:                  
138:                   PreCondition:    
139:                 	None
140:                  
141:                   Parameters:           
142:                 	sys_clock - system clock in Hz
143:                  
144:                   Returns:          
145:                 	None
146:                  
147:                   Side Effects:    
148:                 	The Wait States may be changed  
149:                  
150:                   Remarks:         
151:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
152:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
153:                  
154:                   Example:
155:                 	<code>
156:                 	SYSTEMConfigWaitStates(72000000);
157:                 	</code>
158:                  ********************************************************************/
159:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
160:                 {
161:                 #ifdef _PCACHE
162:                     unsigned int wait_states;
163:                     unsigned int int_status;
164:                 #endif
165:                 
166:                 #ifdef _PCACHE
167:                     wait_states = 0;
168:                 
169:                     while(sys_clock > FLASH_SPEED_HZ)
170:                     {
171:                         wait_states++;
172:                         sys_clock -= FLASH_SPEED_HZ;
173:                     }
174:                 
175:                     int_status=INTDisableInterrupts();
176:                     mCheConfigure(wait_states);
177:                     INTRestoreInterrupts(int_status);
178:                 
179:                 #endif
180:                 }
181:                 
182:                 /*********************************************************************
183:                   Function:        
184:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
185:                   
186:                   Description:
187:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
188:                  
189:                   PreCondition:    
190:                 	None
191:                  
192:                   Parameters:           
193:                 	sys_clock - system clock in Hz
194:                  
195:                   Returns:          
196:                 	the PB clock frequency in Hz
197:                  
198:                   Side Effects:    
199:                 	The PB clock and wait states may be changed
200:                 
201:                   Remarks:            
202:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
203:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
204:                  
205:                   Example:
206:                 	<code>
207:                 	SYSTEMConfigWaitStatesAndPB(72000000);
208:                 	</code>
209:                  ********************************************************************/
210:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
211:                 {
212:                 #ifdef _PCACHE
213:                     unsigned int wait_states;
214:                 #endif
215:                     unsigned int pb_clock;
216:                     unsigned int int_status;
217:                 
218:                     pb_clock = SYSTEMConfigPB(sys_clock);
9D000720  AFC2003C   SW V0, 60(S8)
219:                 
220:                 
221:                     // set the flash wait states based on 1 wait state
222:                     // for every 20 MHz
223:                 #ifdef _PCACHE
224:                     wait_states = 0;
9D000724  AFC00040   SW ZERO, 64(S8)
9D000728  0B4001D4   J 0x9D000750
9D00072C  00000000   NOP
225:                 
226:                     while(sys_clock > FLASH_SPEED_HZ)
9D000750  8FC30014   LW V1, 20(S8)
9D000754  3C0201C9   LUI V0, 457
9D000758  3442C381   ORI V0, V0, -15487
9D00075C  0062102B   SLTU V0, V1, V0
9D000760  1040FFF3   BEQ V0, ZERO, 0x9D000730
9D000764  00000000   NOP
227:                     {
228:                         wait_states++;
9D000730  8FC20040   LW V0, 64(S8)
9D000734  24420001   ADDIU V0, V0, 1
9D000738  AFC20040   SW V0, 64(S8)
229:                         sys_clock -= FLASH_SPEED_HZ;
9D00073C  8FC30014   LW V1, 20(S8)
9D000740  3C02FE36   LUI V0, -458
9D000744  34423C80   ORI V0, V0, 15488
9D000748  00621021   ADDU V0, V1, V0
9D00074C  AFC20014   SW V0, 20(S8)
230:                     }
231:                 
232:                     int_status=INTDisableInterrupts();
9D000768  0F400394   JAL INTDisableInterrupts
9D00076C  00000000   NOP
9D000770  AFC20044   SW V0, 68(S8)
233:                     mCheConfigure(wait_states);
9D000774  3C02BF88   LUI V0, -16504
9D000778  8FC30040   LW V1, 64(S8)
9D00077C  AC434000   SW V1, 16384(V0)
234:                     INTRestoreInterrupts(int_status);
9D000780  8FC40044   LW A0, 68(S8)
9D000784  0F40037F   JAL INTRestoreInterrupts
9D000788  00000000   NOP
235:                 
236:                 #endif
237:                 
238:                     return pb_clock;
9D00078C  8FC2003C   LW V0, 60(S8)
239:                 }
240:                 /*********************************************************************
241:                   Function:       
242:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
243:                  
244:                   Description:
245:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
246:                     It also enables the cacheability for the K0 segment.
247:                 	
248:                   PreCondition:    
249:                 	None
250:                  
251:                   Parameters:           
252:                 	sys_clock - system clock in Hz
253:                  
254:                   Output:          
255:                 	the PB clock frequency in Hz
256:                  
257:                   Side Effects:    
258:                 	Sets the PB and Flash Wait states
259:                  	
260:                   Remarks:            
261:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
262:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
263:                  
264:                   Example:
265:                 	<code>
266:                 	SYSTEMConfigPerformance(72000000);
267:                 	</code>
268:                  ********************************************************************/
269:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
270:                 {
271:                     // set up the wait states
272:                     unsigned int pb_clk;
273:                 #ifdef _PCACHE
274:                     unsigned int cache_status;
275:                 #endif
276:                     unsigned int int_status;
277:                 
278:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
9D000790  AFC20048   SW V0, 72(S8)
279:                 
280:                     int_status=INTDisableInterrupts();
9D000794  0F400394   JAL INTDisableInterrupts
9D000798  00000000   NOP
9D00079C  AFC2004C   SW V0, 76(S8)
281:                 
282:                     mBMXDisableDRMWaitState();
9D0007A0  3C02BF88   LUI V0, -16504
9D0007A4  24030040   ADDIU V1, ZERO, 64
9D0007A8  AC432004   SW V1, 8196(V0)
283:                 
284:                 #ifdef _PCACHE
285:                     cache_status = mCheGetCon();
9D0007AC  3C02BF88   LUI V0, -16504
9D0007B0  8C424000   LW V0, 16384(V0)
9D0007B4  AFC20050   SW V0, 80(S8)
286:                     cache_status |= CHE_CONF_PF_ALL;
9D0007B8  8FC20050   LW V0, 80(S8)
9D0007BC  34420030   ORI V0, V0, 48
9D0007C0  AFC20050   SW V0, 80(S8)
287:                     mCheConfigure(cache_status);
9D0007C4  3C02BF88   LUI V0, -16504
9D0007C8  8FC30050   LW V1, 80(S8)
9D0007CC  AC434000   SW V1, 16384(V0)
288:                     CheKseg0CacheOn();
9D0007D0  0F400386   JAL CheKseg0CacheOn
9D0007D4  00000000   NOP
289:                 #endif
290:                 
291:                     INTRestoreInterrupts(int_status);
9D0007D8  8FC4004C   LW A0, 76(S8)
9D0007DC  0F40037F   JAL INTRestoreInterrupts
9D0007E0  00000000   NOP
292:                 
293:                     return pb_clk;
294:                 
295:                 }
296:                 /*********************************************************************
297:                   Function:       
298:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
299:                  
300:                   Description:
301:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
302:                 	based on the flags selected and on the frequency of the system clock.
303:                     It also enables the cacheability for the K0 segment.
304:                 				   
305:                   PreCondition:    
306:                 	None
307:                  
308:                   Parameters:           
309:                 	sys_clock - system clock frequency in Hz
310:                     flags -
311:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
312:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
313:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
314:                         *    SYS_CFG_ALL          - configure all based on system clock
315:                  
316:                   Returns:          
317:                 	the PB clock frequency in Hz
318:                  
319:                   Side Effects:    
320:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
321:                     wait state to 0.
322:                   
323:                  
324:                   Remarks:
325:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
326:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
327:                  
328:                   Example:
329:                 	<code>
330:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
331:                 	</code>
332:                  ********************************************************************/
333:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
334:                 {
335:                     unsigned int pb_clk;
336:                     unsigned int int_status;
337:                 #ifdef _PCACHE
338:                     unsigned int cache_status;
339:                 #endif
340:                 
341:                     int_status=INTDisableInterrupts();
342:                 
343:                     mBMXDisableDRMWaitState();
344:                 
345:                     if(flags & SYS_CFG_WAIT_STATES)
346:                     {
347:                         SYSTEMConfigWaitStates(sys_clock);
348:                     }
349:                 
350:                     if(flags & SYS_CFG_PB_BUS)
351:                     {
352:                         SYSTEMConfigPB(sys_clock);
353:                     }
354:                 
355:                 
356:                 #ifdef _PCACHE
357:                     if(flags & SYS_CFG_PCACHE)
358:                     {
359:                         cache_status = mCheGetCon();
360:                         cache_status |= CHE_CONF_PF_ALL;
361:                         mCheConfigure(cache_status);
362:                         CheKseg0CacheOn();
363:                     }
364:                 #endif
365:                 
366:                     pb_clk = sys_clock;
367:                     pb_clk >>= OSCCONbits.PBDIV;
368:                 
369:                     INTRestoreInterrupts(int_status);
370:                 
371:                     return pb_clk;
372:                 
373:                 }
374:                 #ifdef __cplusplus
375:                   }
376:                 #endif
377:                 #endif
378:                 
---  c:/program files/microchip/xc32/v1.30/pic32mx/include/peripheral/osc.h  ----------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the ?Company?) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Company?s customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  #define _OSC_
47:                  
48:                  /*********************************************************************
49:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
50:                   *
51:                   * Description:	    Sets Osc options and clock source
52:                   *
53:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
54:                   *
55:                   * Inputs:	    	Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
56:                   *
57:                   * Output:          None
58:                   *
59:                   * Example:	    	OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
60:                   *
61:                   * Note:	    	Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
62:                   * 		     		source and then switches to the new clock source
63:                   *
64:                   *		    		Unused parameters are set to zero/default values.
65:                   ********************************************************************/
66:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
67:                  
68:                  	/******************************************************************************
69:                  	 * Available options for source parameter
70:                  	 *****************************************************************************/
71:                  		// CPU Oscillator modes - values are mutually exclusive
72:                  		#define OSC_FRC_DIV 	(7 << _OSCCON_NOSC_POSITION)
73:                  		#define OSC_FRC_DIV16 	(6 << _OSCCON_NOSC_POSITION)
74:                  		#define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
75:                  		#define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
76:                  		#define OSC_POSC_PLL 	(3 << _OSCCON_NOSC_POSITION)
77:                  		#define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
78:                  		#define OSC_FRC_PLL 	(1 << _OSCCON_NOSC_POSITION)
79:                  		#define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
80:                  
81:                  	/******************************************************************************
82:                  	 * Available options for mult parameter
83:                  	 *****************************************************************************/
84:                  		// CPU PLL multiplier values - values are mutually exclusive
85:                  		#define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
86:                  		#define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
87:                  		#define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
88:                  		#define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
89:                  		#define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
90:                  		#define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
91:                  		#define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
92:                  		#define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
93:                  
94:                  	/******************************************************************************
95:                  	 * Available options for post parameter
96:                  	 *****************************************************************************/
97:                  		// CPU PLL output divisor values - values are mutuallye exclusive
98:                  		#define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
99:                  		#define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
100:                 		#define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
101:                 		#define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
102:                 		#define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
103:                 		#define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
104:                 		#define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
105:                 		#define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
106:                 
107:                 	/******************************************************************************
108:                 	 * Available options for div parameter
109:                 	 *****************************************************************************/
110:                 		// CPU FRC output divisor values - values are mutually exclusive
111:                 		#define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
112:                 		#define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
113:                 		#define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
114:                 		#define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
115:                 		#define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
116:                 		#define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
117:                 		#define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
118:                 		#define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
119:                 	/***********************************
120:                 	 * End parameter values
121:                 	 ************************************/
122:                 
123:                 #if (((__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)) || \
124:                     (__PIC32_FEATURE_SET__ == 330) || (__PIC32_FEATURE_SET__ == 350) || (__PIC32_FEATURE_SET__ == 370) || (__PIC32_FEATURE_SET__ == 430) || (__PIC32_FEATURE_SET__ == 450) || (__PIC32_FEATURE_SET__ == 470))
125:                 	
126:                 		// Reference Oscillator Source Select bits - values are mutually exclusive
127:                 	#define OSC_REFOCON_REFCLKI	 	(7 << _REFOCON_ROSEL_POSITION )
128:                 	#define OSC_REFOCON_SYSPLL 		(7 << _REFOCON_ROSEL_POSITION )
129:                 	#define OSC_REFOCON_USBPLL 		(6 << _REFOCON_ROSEL_POSITION )
130:                 	#define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
131:                 	#define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
132:                 	#define OSC_REFOCON_FRC 		(3 << _REFOCON_ROSEL_POSITION )
133:                 	#define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
134:                 	#define OSC_REFOCON_PBCLK 		(1 << _REFOCON_ROSEL_POSITION )
135:                 	#define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
136:                 		
137:                 	typedef enum
138:                 	{		
139:                 		OSC_REFOCON_RLSPEN		=(1 << _REFOCON_RSLP_POSITION )	,
140:                 		OSC_REFOCON_OE			=(1 << _REFOCON_OE_POSITION ),
141:                 		OSC_REFOCON_SIDLEN		=(1 << _REFOCON_SIDL_POSITION ),
142:                 		OSC_REFOCON_ON			=(1 << _REFOCON_ON_POSITION )
143:                 	} OSCREFConfigFlags;
144:                 	
145:                 	void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
146:                 	 
147:                 
148:                 	#define mOSCREFOTRIMSet(trim) 		(REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
149:                 
150:                 #endif
151:                 
152:                 	 
153:                 	 
154:                 	 
155:                 /*********************************************************************
156:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
157:                  *
158:                  * Description:	Configures peripheral bus divisor
159:                  *
160:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
161:                  *
162:                  * Inputs:    oscPbDiv - desired PB divider
163:                  *
164:                  * Output:      None
165:                  *
166:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
167:                  *
168:                  ********************************************************************/
169:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
170:                 {
171:                 	unsigned int dma_status;
172:                 	unsigned int int_status;
173:                 	__OSCCONbits_t oscBits;
174:                 
175:                 	mSYSTEMUnlock(int_status, dma_status);
9D0005DC  0F400394   JAL INTDisableInterrupts
9D0005E0  00000000   NOP
9D0005E4  AFC20028   SW V0, 40(S8)
9D00062C  AFC20030   SW V0, 48(S8)
9D000630  3C02BF81   LUI V0, -16511
9D000634  AC40F230   SW ZERO, -3536(V0)
9D000638  3C02BF81   LUI V0, -16511
9D00063C  3C03AA99   LUI V1, -21863
9D000640  34636655   ORI V1, V1, 26197
9D000644  AC43F230   SW V1, -3536(V0)
9D000648  3C02BF81   LUI V0, -16511
9D00064C  3C035566   LUI V1, 21862
9D000650  346399AA   ORI V1, V1, -26198
9D000654  AC43F230   SW V1, -3536(V0)
176:                 	
177:                 	oscBits.w=OSCCON;		// read to be in sync. flush any pending write
9D000658  3C02BF81   LUI V0, -16511
9D00065C  8C42F000   LW V0, -4096(V0)
9D000660  AFC20054   SW V0, 84(S8)
178:                 	oscBits.PBDIV=0;
9D000664  8FC20054   LW V0, 84(S8)
9D000668  7C02A4C4   INS V0, ZERO, 19, 2
9D00066C  AFC20054   SW V0, 84(S8)
179:                 	oscBits.w|=oscPbDiv;	
9D000670  8FC30054   LW V1, 84(S8)
9D000674  8FC20024   LW V0, 36(S8)
9D000678  00621025   OR V0, V1, V0
9D00067C  AFC20054   SW V0, 84(S8)
180:                 	OSCCON=oscBits.w;		// write back
9D000680  8FC30054   LW V1, 84(S8)
9D000684  3C02BF81   LUI V0, -16511
9D000688  AC43F000   SW V1, -4096(V0)
181:                 	oscBits.w=OSCCON;		// make sure the write occurred before returning from this function
9D00068C  3C02BF81   LUI V0, -16511
9D000690  8C42F000   LW V0, -4096(V0)
9D000694  AFC20054   SW V0, 84(S8)
182:                 	
183:                 	mSYSTEMLock(int_status, dma_status);
9D000698  3C02BF81   LUI V0, -16511
9D00069C  3C033333   LUI V1, 13107
9D0006A0  34633333   ORI V1, V1, 13107
9D0006A4  AC43F230   SW V1, -3536(V0)
9D0006A8  8FC20030   LW V0, 48(S8)
9D0006AC  AFC20034   SW V0, 52(S8)
9D000710  8FC40028   LW A0, 40(S8)
9D000714  0F40037F   JAL INTRestoreInterrupts
9D000718  00000000   NOP
184:                 }
185:                 
186:                 #define		mOSCSetPBDIV		OSCSetPBDIV		// backward compatibility
187:                 
188:                 
189:                 
190:                 	/******************************************************************************
191:                 	 * Available options for config parameter
192:                 	 *****************************************************************************/
193:                 		// CPU Peripheral Bus divisor values - values are mutually exclusive
194:                 		#define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
195:                 		#define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
196:                 		#define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
197:                 		#define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
198:                 	/***********************************
199:                 	 * End config parameter values
200:                 	 ************************************/
201:                 
202:                 
203:                 /*********************************************************************
204:                  * Function:    mOSCGetPBDIV()
205:                  *
206:                  * Description:	Reads peripheral bus divisor
207:                  *
208:                  * PreCondition:None
209:                  *
210:                  * Inputs:	  	None
211:                  *
212:                  * Output:      None
213:                  *
214:                  * Example:	  	mOSCGetPBDIV()
215:                  *
216:                  ********************************************************************/
217:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
218:                 
219:                 
220:                 /*********************************************************************
221:                  * Function:    mOSCClockFailStatus()
222:                  *
223:                  * Description:	Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
224:                  *
225:                  * PreCondition: None
226:                  *
227:                  * Inputs:	  	None
228:                  *
229:                  * Output:      None
230:                  *
231:                  * Example:	  	mOSCClockFailStatus()
232:                  *
233:                  ********************************************************************/
234:                 #define mOSCClockFailStatus (OSCCONbits.CF)
235:                 
236:                 
237:                 /*********************************************************************
238:                  * Function:      	mOSCEnableSOSC()
239:                  *
240:                  * Description:	  	Enables the LPRC
241:                  *
242:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
243:                  *
244:                  * Inputs:	  		None
245:                  *
246:                  * Output:        	None
247:                  *
248:                  * Example:	  		mOSCEnableSOSC()
249:                  *
250:                  ********************************************************************/
251:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
252:                 
253:                 
254:                 /*********************************************************************
255:                  * Function:      	mOSCDisableSOSC(config)
256:                  *
257:                  * Description:	  	Disables SOSC
258:                  *
259:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
260:                  *
261:                  * Inputs:	  		None
262:                  *
263:                  * Output:        	None
264:                  *
265:                  * Example:	  		mOSCDisableSOSC()
266:                  *
267:                  ********************************************************************/
268:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
269:                 
270:                 
271:                 
272:                 #endif
---  c:/program files/microchip/xc32/v1.30/pic32mx/include/peripheral/dma_5xx_6xx_7xx.h  ----------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:	xc.h
8:                    * 					int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Complier:        MPLAB C32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the ?Company?) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Company?s customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_H_
43:                  #define _DMA_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  
48:                  // DMA definitions
49:                  
50:                  #ifdef _DMAC0
51:                  	#define _DMA_CHANNELS		// DMA channels exist
52:                  
53:                  
54:                  // existent DMA channels
55:                  	typedef enum
56:                  	{
57:                  		DMA_CHANNEL0,
58:                  	#ifdef _DMAC1
59:                  		DMA_CHANNEL1,
60:                  	#ifdef _DMAC2
61:                  		DMA_CHANNEL2,
62:                  	#ifdef _DMAC3
63:                  		DMA_CHANNEL3,
64:                  	#ifdef _DMAC4
65:                  		DMA_CHANNEL4,
66:                  	#ifdef _DMAC5
67:                  		DMA_CHANNEL5,
68:                  	#ifdef _DMAC6
69:                  		DMA_CHANNEL6,
70:                  	#ifdef _DMAC7
71:                  		DMA_CHANNEL7,
72:                  	#endif	// _DMAC7
73:                  	#endif	// _DMAC6
74:                  	#endif	// _DMAC5
75:                  	#endif	// _DMAC4
76:                  	#endif	// _DMAC3
77:                  	#endif	// _DMAC2
78:                  	#endif	// _DMAC1
79:                  		//	add/remove DMA channel as needed here
80:                  
81:                  		DMA_CHANNELS	// number of current available channels
82:                  	}DmaChannel;
83:                  
84:                  
85:                  	// Relative Dma channels priority, between each other
86:                  	typedef enum
87:                  	{
88:                  		DMA_CHN_PRI0,
89:                  		DMA_CHN_PRI1,
90:                  		DMA_CHN_PRI2,
91:                  		DMA_CHN_PRI3
92:                  	}DmaChannelPri;
93:                  
94:                  
95:                  
96:                  	// high level definitions for the API functions
97:                  
98:                  	typedef enum
99:                  	{
100:                 		DMA_OPEN_DEFAULT = 0,							        // DMA default operation
101:                 		DMA_OPEN_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
102:                 		DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
103:                 		DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),				// DMA channel is chained to higher channel
104:                 		DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,					// events detection enabled while channel off
105:                 		DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
106:                 		DMA_OPEN_MATCH	= 0x80000000,						    // DMA channel stops on match
107:                 	}DmaOpenFlags;	// flags for the channel open
108:                 
109:                 
110:                 	typedef enum
111:                 	{
112:                 		DMA_EV_ERR =			0x1,		// address error event
113:                 		DMA_EV_ABORT = 			0x2,		// transfer abort event
114:                 		DMA_EV_CELL_DONE =		0x4,		// cell transfer complete event
115:                 		DMA_EV_BLOCK_DONE =		0x8,		// block transfer complete event
116:                 		DMA_EV_DST_HALF =		0x10,		// destination half event
117:                 		DMA_EV_DST_FULL =		0x20,		// destination full event
118:                 		DMA_EV_SRC_HALF =		0x40,		// source half event
119:                 		DMA_EV_SRC_FULL =		0x80,		// source full event
120:                 
121:                 		DMA_EV_ALL_EVNTS=		(DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
122:                 									DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)				// all available events
123:                 	}DmaEvFlags;	// flags for controlling the DMA channel events; Bit fields from the processor header file.
124:                 
125:                 
126:                 	typedef enum
127:                 	{
128:                 		DMA_TXFER_OK,			// the transfer was performed successfully
129:                 		DMA_TXFER_ADD_ERR,		// address error while performing the transfer
130:                 		DMA_TXFER_ABORT,		// the DMA transfer was aborted
131:                 		DMA_TXFER_BC_ERR,		// block complete not set after the DMA transfer performed
132:                 		DMA_TXFER_CC_ERR,		// cell complete not set after the DMA transfer performed
133:                 		DMA_TXFER_TMO			// DMA transfer timeout
134:                 	}DmaTxferRes;		// DMA transfer result
135:                 
136:                 	typedef enum
137:                 	{
138:                 		DMA_WAIT_NOT,		// don't wait for the transfer to complete, return immediately
139:                 		DMA_WAIT_CELL,		// wait for the cell transfer to complete, than return
140:                 		DMA_WAIT_BLOCK		// wait for the block transfer to complete, than return
141:                 	}DmaWaitMode;		// DMA transfer wait mode
142:                 
143:                 	typedef enum
144:                 	{
145:                 		DMA_CHKSUM_CRC,		// LFSR CRC
146:                 		DMA_CHKSUM_IP,		// IP Checksum
147:                 	}DmaChksumType;		// DMA SFM supported checksum types
148:                 
149:                 	typedef enum
150:                 	{
151:                 		DMA_BITO_MSb,		// MSb first (not reflected)
152:                 		DMA_BITO_LSb,		// LSb first (reflected)
153:                 	}DmaBitOrder;		// DMA SFM supported bit ordering
154:                 
155:                 	typedef enum
156:                 	{
157:                 		DMA_REORDER_NOT,	// no reordering, destination matches the source
158:                 		DMA_REORDER_ENDIAN,	// change endianess on word (32 bit) boundaries: LE<->BE
159:                 		DMA_REORDER_SWAP_HALF,	// swap half words (16 bit) within word (32 bit)		
160:                 		DMA_REORDER_SWAP_BYTE,	// swap bytes within half word (16 bit)				
161:                 	}DmaReorderMode;	// DMA SFM supported re-ordering modes
162:                 
163:                 
164:                 	/*********************************************************************
165:                 	 * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
166:                 	 *
167:                 	 * PreCondition:    chPri  - valid channel priority, 0-3
168:                 	 *
169:                 	 * Input:           chn    - channel to be configured in the DMA controller
170:                 	 *                  chPri  - the priority given to the channel, 0-3
171:                 	 *                  oFlags - orred flags specifying the open mode:
172:                 	 *                           DMA_OPEN_DEFAULT: DMA default operation mode
173:                 	 *                           DMA_OPEN_AUTO:	DMA channel is auto enabled
174:                 	 *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
175:                 	 *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
176:                 	 *                           DMA_OPEN_DET_EN: events detection enabled while channel off
177:                 	 *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
178:                 	 *                           DMA_OPEN_MATCH:	DMA channel stops on match
179:                 	 *
180:                 	 *
181:                 	 *
182:                 	 * Output:          None
183:                 	 *
184:                 	 * Side Effects:    None
185:                 	 *
186:                 	 * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
187:                 	 *
188:                 	 * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
189:                 	 *                  Use the low level functions to address special settings.
190:                 	 *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
191:                 	 *                  After that the channel is configured.
192:                 	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
193:                 	 *                  if DMA_OPEN_ENABLE flag was not specified.
194:                 	 *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
195:                 	 *                  This way, the transfer will occur correctly together with CRC calculation.
196:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
197:                 	 *                  User has to call event channel functions to enable the event flags if needed.
198:                 	 *
199:                 	 * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
200:                 	 ********************************************************************/
201:                 	 void			DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
202:                 
203:                 	/*********************************************************************
204:                 	 * Function:        void DmaChnEnable(DmaChannel chn)
205:                 	 *
206:                 	 * PreCondition:    None
207:                 	 *
208:                 	 * Input:			chn		- channel to be enabled
209:                 	 *
210:                 	 * Output:          None
211:                 	 *
212:                 	 * Side Effects:    None
213:                 	 *
214:                 	 * Overview:		The function enables a previously configured DMA channel.
215:                 	 *
216:                 	 * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
217:                 	 *
218:                 	 * Example:			DmaChnEnable(DMA_CHANNEL3);
219:                 	 ********************************************************************/
220:                 	 void			DmaChnEnable(DmaChannel chn);
221:                 
222:                 	/*********************************************************************
223:                 	 * Function:        void DmaChnDisable(DmaChannel chn)
224:                 	 *
225:                 	 * PreCondition:    None
226:                 	 *
227:                 	 * Input:			chn		- selected channel in the DMA controller
228:                 	 *
229:                 	 * Output:          None
230:                 	 *
231:                 	 * Side Effects:    None
232:                 	 *
233:                 	 * Overview:		The function disables a DMA channel. The channel operation stops.
234:                 	 *
235:                 	 * Note:            None.
236:                 	 *
237:                 	 * Example:			DmaChnDisable(DMA_CHANNEL3);
238:                 	 ********************************************************************/
239:                 	 void			DmaChnDisable(DmaChannel chn);
240:                 
241:                 	/*********************************************************************
242:                 	 * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
243:                 	 *
244:                 	 * PreCondition:    chn		- valid DMA channel
245:                 	 * 				- vSrcAdd, vDstAdd	- valid pointers
246:                 	 *                              - 0 < srcSize <= DmaGetMaxTxferSize()
247:                 	 *                              - 0 < dstSize <= DmaGetMaxTxferSize()
248:                 	 *                              - 0 < cellSize <= DmaGetMaxTxferSize()
249:                 	 *
250:                 	 * Input:			chn			- DMA channel number
251:                 	 * 								- vSrcAdd: source of the DMA transfer
252:                 	 * 								- vDstAdd: destination of the DMA transfer
253:                 	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
254:                 	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
255:                 	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
256:                 	 *
257:                 	 * Output:          None
258:                 	 *
259:                 	 * Side Effects:    None
260:                 	 *
261:                 	 * Overview:		The function sets the transfer characteristics for a DMA channel transfer:
262:                 	 * 					the source and the destination addresses.
263:                 	 * 					the source and destination lengths
264:                 	 * 					and the number of bytes	transferred per event.
265:                 	 *
266:                 	 * Note:            The function clears the existing DMA channel event flags.
267:                 	 *                  The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
268:                 	 *
269:                 	 * Example:			DmaChnSetTxfer(DMA_CHANNEL3, &U2RXREG, dstBuff, 1, 200, 1);
270:                 	 ********************************************************************/
271:                 	 void			DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
272:                 
273:                 
274:                 	/*********************************************************************
275:                 	 * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
276:                 	 *
277:                 	 * PreCondition:    chn		- valid DMA channel
278:                 	 *
279:                 	 * Input:           chn		- DMA channel number
280:                 	 * 				- vSrcAdd: source (virtual) of the DMA transfer
281:                 	 * Output:          None
282:                 	 *
283:                 	 * Side Effects:    None
284:                 	 *
285:                 	 * Overview:        The function is a helper to set directly the transfer source address.
286:                 	 *
287:                 	 * Note:            None.
288:                 	 *
289:                 	 * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
290:                 	 ********************************************************************/
291:                 	 void			DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
292:                 
293:                 	/*********************************************************************
294:                 	 * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
295:                 	 *
296:                 	 * PreCondition:    chn		- valid DMA channel
297:                 	 *
298:                 	 * Input:			chn			- DMA channel number
299:                 	 * 								- vDstAdd: destination (virtual) of the DMA transfer
300:                 	 * Output:          None
301:                 	 *
302:                 	 * Side Effects:    None
303:                 	 *
304:                 	 * Overview:		The function is a helper to set directly the transfer destination address.
305:                 	 *
306:                 	 * Note:            None
307:                 	 *
308:                 	 * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
309:                 	 ********************************************************************/
310:                 	 void			DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
311:                 
312:                 	/*********************************************************************
313:                 	 * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
314:                 	 *
315:                 	 * PreCondition:    chn	- valid DMA channel
316:                 	 *
317:                 	 * Input:			chn		- DMA channel number
318:                 	 * 					pattern	-  the match pattern
319:                 	 *
320:                 	 * Output:          None
321:                 	 *
322:                 	 * Side Effects:    None
323:                 	 *
324:                 	 * Overview:		The function sets the curent match pattern for the selected DMA channel.
325:                 	 *
326:                 	 * Note:            None.
327:                 	 *
328:                 	 * Example:			DmaChnSetMatchPattern(DMA_CHANNEL3, '\r');
329:                 	 ********************************************************************/
330:                 	 void			DmaChnSetMatchPattern(DmaChannel chn, int pattern);
331:                 
332:                 	/*********************************************************************
333:                 	 * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
334:                 	 *
335:                 	 * PreCondition:    chn	- valid DMA channel
336:                 	 *
337:                 	 * Input:			chn		- DMA channel number
338:                 	 *
339:                 	 * Output:          The channel match pattern.
340:                 	 *
341:                 	 * Side Effects:    None
342:                 	 *
343:                 	 * Overview:		The function retrieves the curent match pattern for the selected DMA channel.
344:                 	 *
345:                 	 * Note:            None.
346:                 	 *
347:                 	 * Example:			int pattern=DmaChnGetMatchPattern(DMA_CHANNEL3);
348:                 	 ********************************************************************/
349:                 	 int			DmaChnGetMatchPattern(DmaChannel chn);
350:                 
351:                 	/*********************************************************************
352:                 	 * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
353:                 	 *
354:                 	 * PreCondition:    chn	- valid DMA channel
355:                 	 *
356:                 	 * Input:			chn		- DMA channel number
357:                 	 * 					wMode	- if DMA_WAIT_NOT, return immediately
358:                 	 * 							- if DMA_WAIT_CELL, return after the cell transfer complete
359:                 	 * 							- if DMA_WAIT_BLOCK, return after the whole transfer is done
360:                 	 * 					retries	- retry counter: if transfer not complete after so many retries, return with tmo.
361:                 	 * 								If 0, wait forever.
362:                 	 *
363:                 	 * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
364:                 	 * 					an DmaTxferRes error code  otherwise
365:                 	 *
366:                 	 * Side Effects:    None
367:                 	 *
368:                 	 * Overview:		The function initiates (forces) a DMA transfer for the selected DMA channel.
369:                 	 * 					The DMA channel is enabled.
370:                 	 * 					If waiting for the transfer completion needed (user doesn't use an ISR to catch
371:                 	 * 					this event) the function will periodically query the DMA controller for the
372:                 	 * 					transfer completion status.
373:                      * 					If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
374:                      * 					the block transfer than the function will re-force the transfer for each cell.
375:                 	 *
376:                 	 * Note:            This function can not ne used when the DMA channel is triggerred
377:                      *                  by hardware interrupt requests.
378:                      *                  This is because the transfers are software forced, theere is no
379:                      *                  wait for the occurrence of the hardware trigger. 
380:                 	 *
381:                 	 * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
382:                 	 ********************************************************************/
383:                 	 DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
384:                 
385:                 	/*********************************************************************
386:                 	 * Function:        void DmaChnForceTxfer(DmaChannel chn)
387:                 	 *
388:                 	 * PreCondition:    chn	- valid DMA channel
389:                 	 *
390:                 	 * Input:			chn		- DMA channel number
391:                 	 *
392:                 	 * Output:          None
393:                 	 *
394:                 	 * Side Effects:    None
395:                 	 *
396:                 	 * Overview:		The function forces a DMA transfer to occur for the selected DMA channel.
397:                 	 *
398:                 	 * Note:            None.
399:                 	 *
400:                 	 * Example:			DmaChnForceTxfer(DMA_CHANNEL3);
401:                 	 ********************************************************************/
402:                 	 void			DmaChnForceTxfer(DmaChannel chn);
403:                 
404:                 	/*********************************************************************
405:                 	 * Function:        void DmaChnAbortTxfer(DmaChannel chn)
406:                 	 *
407:                 	 * PreCondition:    chn	- valid DMA channel
408:                 	 *
409:                 	 * Input:			chn		- DMA channel number
410:                 	 *
411:                 	 * Output:          None
412:                 	 *
413:                 	 * Side Effects:    None
414:                 	 *
415:                 	 * Overview:		The function aborts a current undergoing DMA transfer for the selected DMA channel.
416:                 	 *
417:                 	 * Note:            None.
418:                 	 *
419:                 	 * Example:			DmaChnAbortTxfer(DMA_CHANNEL3);
420:                 	 ********************************************************************/
421:                 	 void			DmaChnAbortTxfer(DmaChannel chn);
422:                 
423:                 	// High level channel event and interrupt control functions
424:                 
425:                 	/*********************************************************************
426:                 	 * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
427:                 	 *
428:                 	 * PreCondition:    chn	- valid DMA channel
429:                 	 *
430:                 	 * Input:			chn		- DMA channel number
431:                 	 * 					eFlags	- event flags with the following significance:
432:                 	 * 								- DMA_EV_ERR: address error event
433:                 	 * 								- DMA_EV_ABORT: transfer abort event
434:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
435:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
436:                 	 * 								- DMA_EV_DST_HALF: destination half event
437:                 	 * 								- DMA_EV_DST_FULL: destination full event
438:                 	 * 								- DMA_EV_SRC_HALF: source half event
439:                 	 * 								- DMA_EV_SRC_FULL: source full event
440:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
441:                 	 *
442:                 	 * Output:          None
443:                 	 *
444:                 	 * Side Effects:    None
445:                 	 *
446:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
447:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
448:                 	 * 					enabled for the selected channel, the other channel event flags won't be touched.
449:                 	 *
450:                 	 * Note:            None.
451:                 	 *
452:                 	 * Example:			DmaChnSetEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
453:                 	 ********************************************************************/
454:                 	 void			DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
455:                 
456:                 	/*********************************************************************
457:                 	 * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
458:                 	 *
459:                 	 * PreCondition:    chn	- valid DMA channel
460:                 	 *
461:                 	 * Input:			chn		- DMA channel number
462:                 	 * 					eFlags	- event flags with the following significance:
463:                 	 * 								- DMA_EV_ERR: address error event
464:                 	 * 								- DMA_EV_ABORT: transfer abort event
465:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
466:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
467:                 	 * 								- DMA_EV_DST_HALF: destination half event
468:                 	 * 								- DMA_EV_DST_FULL: destination full event
469:                 	 * 								- DMA_EV_SRC_HALF: source half event
470:                 	 * 								- DMA_EV_SRC_FULL: source full event
471:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
472:                 	 *
473:                 	 * Output:          None
474:                 	 *
475:                 	 * Side Effects:    None
476:                 	 *
477:                 	 * Overview:		The function clears the event enable flags for the selected DMA channel.
478:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
479:                 	 * 					disabled for the selected channel, the other channel event flags won't be touched.
480:                 	 *
481:                 	 * Note:            None.
482:                 	 *
483:                 	 * Example:			DmaChnClrEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
484:                 	 ********************************************************************/
485:                 	 void			DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
486:                 
487:                 	/*********************************************************************
488:                 	 * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
489:                 	 *
490:                 	 * PreCondition:    chn	- valid DMA channel
491:                 	 *
492:                 	 * Input:			chn		- DMA channel number
493:                 	 * 					eFlags	- event flags with the following significance:
494:                 	 * 								- DMA_EV_ERR: address error event
495:                 	 * 								- DMA_EV_ABORT: transfer abort event
496:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
497:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
498:                 	 * 								- DMA_EV_DST_HALF: destination half event
499:                 	 * 								- DMA_EV_DST_FULL: destination full event
500:                 	 * 								- DMA_EV_SRC_HALF: source half event
501:                 	 * 								- DMA_EV_SRC_FULL: source full event
502:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
503:                 	 *
504:                 	 * Output:          None
505:                 	 *
506:                 	 * Side Effects:    None
507:                 	 *
508:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
509:                 	 * 					The channel event flags are forced to the eFlags value.
510:                 	 *
511:                 	 * Note:            None.
512:                 	 *
513:                 	 * Example:			DmaChnWriteEvEnableFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
514:                 	 ********************************************************************/
515:                 	 void			DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
516:                 
517:                 	/*********************************************************************
518:                 	 * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
519:                 	 *
520:                 	 * PreCondition:    chn	- valid DMA channel
521:                 	 *
522:                 	 * Input:			chn		- DMA channel number
523:                 	 *
524:                 	 * Output:          - event flags with the following significance:
525:                 	 * 						- DMA_EV_ERR: address error event
526:                 	 * 						- DMA_EV_ABORT: transfer abort event
527:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
528:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
529:                 	 * 						- DMA_EV_DST_HALF: destination half event
530:                 	 * 						- DMA_EV_DST_FULL: destination full event
531:                 	 * 						- DMA_EV_SRC_HALF: source half event
532:                 	 * 						- DMA_EV_SRC_FULL: source full event
533:                 	 *						- DMA_EV_ALL_EVNTS: all of the above flags
534:                 	 *
535:                 	 * Side Effects:    None
536:                 	 *
537:                 	 * Overview:		The function returns the event enabled flags for the selected DMA channel.
538:                 	 *
539:                 	 * Note:            None.
540:                 	 *
541:                 	 * Example:			DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL3);
542:                 	 ********************************************************************/
543:                 	 DmaEvFlags	DmaChnGetEvEnableFlags(DmaChannel chn);
544:                 
545:                 	/*********************************************************************
546:                 	 * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
547:                 	 *
548:                 	 * PreCondition:    chn	- valid DMA channel
549:                 	 *
550:                 	 * Input:			chn		- DMA channel number
551:                 	 * 					eFlags	- event flags with the following significance:
552:                 	 * 								- DMA_EV_ERR: address error event
553:                 	 * 								- DMA_EV_ABORT: transfer abort event
554:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
555:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
556:                 	 * 								- DMA_EV_DST_HALF: destination half event
557:                 	 * 								- DMA_EV_DST_FULL: destination full event
558:                 	 * 								- DMA_EV_SRC_HALF: source half event
559:                 	 * 								- DMA_EV_SRC_FULL: source full event
560:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
561:                 	 *
562:                 	 * Output:          None
563:                 	 *
564:                 	 * Side Effects:    None
565:                 	 *
566:                 	 * Overview:		The function clears the event flags for the selected DMA channel.
567:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
568:                 	 * 					cleared for the selected channel, the other channel event flags won't be touched.
569:                 	 *
570:                 	 * Note:            None.
571:                 	 *
572:                 	 * Example:			DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
573:                 	 ********************************************************************/
574:                 	 void			DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
575:                 
576:                 	/*********************************************************************
577:                 	 * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
578:                 	 *
579:                 	 * PreCondition:    chn	- valid DMA channel
580:                 	 *
581:                 	 * Input:			chn		- DMA channel number
582:                 	 *
583:                 	 * Output:          event flags with the following significance:
584:                 	 * 						- DMA_EV_ERR: address error event
585:                 	 * 						- DMA_EV_ABORT: transfer abort event
586:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
587:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
588:                 	 * 						- DMA_EV_DST_HALF: destination half event
589:                 	 * 						- DMA_EV_DST_FULL: destination full event
590:                 	 * 						- DMA_EV_SRC_HALF: source half event
591:                 	 * 						- DMA_EV_SRC_FULL: source full event
592:                 	 * 						- DMA_EV_ALL_EVNTS: all of the above flags
593:                 	 *
594:                 	 * Side Effects:    None
595:                 	 *
596:                 	 * Overview:		The function returns the event flags for the selected DMA channel.
597:                 	 *
598:                 	 * Note:            None.
599:                 	 *
600:                 	 * Example:			DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL3);
601:                 	 ********************************************************************/
602:                 	 DmaEvFlags	DmaChnGetEvFlags(DmaChannel chn);
603:                 
604:                 
605:                 	// high level helpers for fast strcpy/memcpy transfers
606:                 
607:                 	/*********************************************************************
608:                 	 * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
609:                 	 *
610:                 	 * PreCondition:    chn		- a valid DMA channel
611:                 	 * 					s1, s2	- valid memory pointers
612:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
613:                 	 *
614:                 	 * Input:			s1		- destination pointer
615:                 	 * 					s2		- source pointer
616:                 	 * 					n		- number of bytes to transfer
617:                 	 * 					chn		- the DMA channel to perform the transfer
618:                 	 * 					chPri	- the desired channel priority
619:                 	 *
620:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
621:                 	 * 					an DmaTxferRes error code  otherwise
622:                 	 *
623:                 	 * Side Effects:    None
624:                 	 *
625:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
626:                 	 * 			Then it copies one block of memory from source to destination.
627:                 	 *
628:                 	 *
629:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
630:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
631:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
632:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
633:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
634:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
635:                 	 *
636:                  	 * Example:		res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL0, DMA_CHN_PRI3);
637:                  	 ********************************************************************/
638:                 	 DmaTxferRes	DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
639:                 
640:                 	/*********************************************************************
641:                 	 * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
642:                 	 *
643:                 	 * PreCondition:    chn		- a valid DMA channel
644:                 	 * 					s1, s2	- valid memory pointers
645:                 	 *
646:                 	 * Input:			s1		- destination pointer
647:                 	 * 					s2		- source pointer
648:                 	 * 					chn		- the DMA channel to perform the transfer
649:                 	 * 					chPri	- the desired channel priority
650:                 	 *
651:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
652:                 	 * 					an DmaTxferRes error code  otherwise
653:                 	 *
654:                 	 * Side Effects:    None
655:                 	 *
656:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
657:                 	 * 			Then it copies one zero terminated string from source to destination.
658:                 	 *
659:                 	 *
660:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
661:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
662:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
663:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
664:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
665:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
666:                 	 *
667:                 	 *
668:                  	 * Example:		res=DmaChnStrcpy(str1, str2, DMA_CHANNEL1, DMA_CHN_PRI3);
669:                 	 *********************************************************************/
670:                 	 DmaTxferRes	DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
671:                 
672:                 	/*********************************************************************
673:                 	 * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
674:                 	 *
675:                 	 * PreCondition:    chn		- a valid DMA channel
676:                 	 * 				- s1, s2	- valid memory pointers
677:                 	 *                              - 0 < n <= DmaGetMaxTxferSize()
678:                 	 *
679:                 	 * Input:			s1		- destination pointer
680:                 	 * 					s2		- source pointer
681:                 	 * 					n	- max number of bytes to transfer
682:                 	 * 					chn		- the DMA channel to perform the transfer
683:                 	 * 					chPri	- the desired channel priority
684:                 	 *
685:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
686:                 	 * 					an DmaTxferRes error code  otherwise
687:                 	 *
688:                 	 * Side Effects:    None
689:                 	 *
690:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
691:                 	 * 			Then it copies one zero terminated string from source to destination.
692:                 	 * 			It copies no more than n characters from s2.
693:                 	 *
694:                 	 *
695:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
696:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
697:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
698:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
699:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
700:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
701:                 	 *
702:                 	 *
703:                  	 * Example:		res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL1, DMA_CHN_PRI3);
704:                 	 ********************************************************************/
705:                 	 DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
706:                 
707:                 	/*********************************************************************
708:                 	 * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
709:                 	 *
710:                 	 * PreCondition:    chn    - a valid DMA channel
711:                 	 *                  d, s   - valid memory pointer
712:                 	 *                  n>0, n<=DmaGetMaxTxferSize()
713:                 	 *
714:                 	 * Input:           d     - address where to deposit the result
715:                 	 *                  s     - source buffer pointer
716:                 	 *                  n     - number of bytes in the pointer
717:                 	 *                  chn   - the DMA channel to use
718:                 	 *                  chPri - the desired channel priority
719:                 	 * 
720:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
721:                 	 *                  an DmaTxferRes error code  otherwise
722:                 	 *
723:                 	 * Side Effects:    None
724:                 	 *
725:                 	 * Overview:        The function is a helper that calculates the CRC of a memory block.
726:                 	 *                  The function configures the DMA channel for a fast memory transfer and calculates the CRC.
727:                 	 *
728:                 	 *
729:                 	 * Note:            - The CRC generator must have been previously configured using DmaSfmCrcConfigure()
730:                 	 *                  - No transfer is done, just the CRC is calculated.
731:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
732:                 	 *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
733:                 	 *                  - The checksum type is switched to CRC.
734:                 	 *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
735:                 	 *                  
736:                 	 * Example:          int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
737:                 	 ********************************************************************/
738:                 	 DmaTxferRes	DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
739:                 
740:                 	/*********************************************************************
741:                 	 * Function:        DmaTxferRes DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
742:                 	 *
743:                 	 * PreCondition:    chn    - a valid DMA channel
744:                 	 *                  d, s   - valid memory pointer
745:                 	 *                  n>0, n<=DmaGetMaxTxferSize()
746:                 	 *
747:                 	 * Input:           d     - address where to deposit the result
748:                 	 *                  s     - source buffer pointer
749:                 	 *                  n     - number of bytes in the pointer
750:                 	 *                  chn   - the DMA channel to use
751:                 	 *                  chPri - the desired channel priority
752:                 	 * 
753:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
754:                 	 *                  an DmaTxferRes error code  otherwise
755:                 	 *
756:                 	 * Side Effects:    None
757:                 	 *
758:                 	 * Overview:        The function is a helper that calculates the IP checksum of a memory block.
759:                 	 *                  The function configures the DMA channel for a fast memory transfer and calculates the IP checksum.
760:                 	 *
761:                 	 *
762:                 	 * Note:            - The checksum generator must have been previously seeded using DmaSfmSetSeed()
763:                 	 *                  - No transfer is done, just the checksum is calculated.
764:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
765:                 	 *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
766:                 	 *                  - The checksum type is switched to IP checksum.
767:                 	 *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
768:                 	 *                  
769:                 	 * Example:          int myChecksum; DmaChnMemChecksum(&myChecksum, srcBuff, sizeof(srcBuff), DMA_CHANNEL1, DMA_CHN_PRI3);
770:                 	 ********************************************************************/
771:                 	 DmaTxferRes	DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
772:                 
773:                 	// High level Special Function Module (SFM) functions
774:                 
775:                 	/*********************************************************************
776:                 	 * Function:        void DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
777:                 	 *
778:                 	 * PreCondition:    cType, bitO, rMode - valid values
779:                 	 *
780:                 	 * Input:           cType - checksum type to be calculated: CRC or IP Checksum
781:                 	 *                  bitO  - the bit order to be used MSb or LSb first
782:                 	 *                  rMode - the reordering mode of the bytes when calculating the checksum 
783:                 	 *
784:                 	 * Output:          None
785:                 	 *
786:                 	 * Side Effects:    Whenever the Transfer re-ordering is enabled the rMode setting will influence the destination data layout
787:                 	 *
788:                 	 * Overview:        The function configures the SFM module by setting the parameters that define the behavior:
789:                 	 *                      - the type of the checksum to be calculated (either CRC or IP checksum are supported)
790:                 	 *                      - the bit ordering (how a specific byte is used in the checksum calculation: MSb or LSb first) 
791:                 	 *                      - the data re-ordering (how bytes are re-ordered before calculating the checksum).
792:                 	 *                      All these values affect the way the checksum is calculated.
793:                 	 *
794:                 	 * Note:            None
795:                 	 *
796:                 	 * Example:         DmaSfmConfigure(DMA_CHKSUM_CRC, DMA_BITO_LSb, DMA_REORDER_ENDIAN);
797:                 	 ********************************************************************/
798:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
799:                 	{
800:                 		DCRCCONCLR=_DCRCCON_CRCTYP_MASK|_DCRCCON_BITO_MASK|_DCRCCON_BYTO_MASK;
801:                 		DCRCCONSET=(cType<<_DCRCCON_CRCTYP_POSITION)|(bitO<<_DCRCCON_BITO_POSITION)|(rMode<<_DCRCCON_BYTO_POSITION);
802:                 	}
803:                 
804:                 	/*********************************************************************
805:                 	 * Function:        void DmaSfmTxferReorder(int enable)
806:                 	 *
807:                 	 * PreCondition:    None
808:                 	 *
809:                 	 * Input:           enable - boolean to enable/disable the re-ordering of the data transfer
810:                 	 *
811:                 	 * Output:          None
812:                 	 *
813:                 	 * Side Effects:    None
814:                 	 *
815:                 	 * Overview:        The function configures the data transfer re-ordering of the SFM module.
816:                 	 *                  If the re-ordering is enabled, the data is read from the source, re-ordered accordingly and then written to the destination.
817:                 	 *                  Otherwise the data is written to the destination un-modified.
818:                 	 *                  The re-ordering is the one specified by the DmaReorderMode parameter in the DmaSfmConfigure() call.
819:                 	 *                  
820:                 	 *
821:                 	 * Note:            - The data transfer re-ordering should be used only for normal (background mode) data transfers.
822:                 	 *                  - In append mode the data transfer re-ordering should not be enabled (undefined behavior)!
823:                 	 *                  - Whenever the data re-ordering is enabled, the transfer should be aligned at both ends (source and destination).
824:                 	 *                    Un-aligned transfers are not supported (undefined behavior)!
825:                 	 *
826:                 	 * Example:         DmaSfmTxferReorder();
827:                 	 ********************************************************************/
828:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmTxferReorder(int enable)
829:                 	{
830:                 		DCRCCONCLR=_DCRCCON_WBO_MASK;
831:                 		DCRCCONSET=(enable<<_DCRCCON_WBO_POSITION);
832:                 	}
833:                 
834:                 
835:                 	 /*********************************************************************
836:                 	 * Function:        void DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
837:                 	 *
838:                 	 * PreCondition:    pLen   - valid polynomial length within 1-32
839:                 	 *
840:                 	 * Input:           polynomial	- the layout of the CRC generator
841:                 	 *                  pLen        - the length of the CRC generator polynomial
842:                 	 *                  seed        - the initial seed of the CRC generator
843:                 	 *
844:                 	 * Output:          None
845:                 	 *
846:                 	 * Side Effects:    None
847:                 	 *
848:                 	 * Overview:        The function configures the SFM CRC module by setting the parameters that define the generator polynomial:
849:                 	 *                  - the length of the CRC generator polynomial, pLen;
850:                 	 *                  - the function sets the layout of the shift stages that take place in the CRC generation.
851:                 	 *                    Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
852:                 	 *                    If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
853:                 	 *                    Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
854:                 	 *                    are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
855:                 	 *                    feedback should be 0x8005, or 0x8004, but not 0x018005;
856:                 	 *                  - the function sets the seed of the CRC generator. This is the initial data present in the
857:                 	 *                   CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
858:                 	 *
859:                 	 * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
860:                 	 *                  - When the append mode is set, the attached DMA channel has to have destination size <=4.
861:                 	 *                    Upon the transfer completion the calculated CRC is stored at the destination address.
862:                 	 *                  - When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
863:                 	 *                    the CrcResult() function.
864:                 	 *                  - The CRC module should be configured before enabled.
865:                 	 *                  - These settings are relevant only when the SFM is configured for the CRC type of checksum.
866:                 	 *                  - The checksum register is the same for CRC or IP checksum mode. Therefore, this function changes also the seed for the IP checksum.
867:                 	 *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
868:                 	 *
869:                 	 * Example:         DmaSfmCrcConfigure(0x04c11db7, 32, 0xffffffff);
870:                 	 ********************************************************************/
871:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
872:                 	{
873:                 		DCRCCONCLR=_DCRCCON_PLEN_MASK;
874:                 		DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
875:                 		DCRCDATA=seed;
876:                 		DCRCXOR=polynomial;
877:                 	}
878:                 	
879:                 	#define DmaCrcConfigure	DmaSfmCrcConfigure	// PIC32_3xx backward compatibility name
880:                 
881:                 
882:                 	/*********************************************************************
883:                 	 * Function:        void DmaSfmAttachChannel(DmaChannel chn, int appendMode)
884:                 	 *
885:                 	 * PreCondition:    chn	   - valid DMA channel
886:                 	 *
887:                 	 * Input:           chn         - the DMA channel to be attached to the checksum module.
888:                 	 *                  appendMode	- if TRUE the data passed to the checksum generator is not transferred to destination
889:                 	 *                                but it's written to the destination address when the block transfer is complete.
890:                 	 *                              - if FALSE the data is transferred normally while the checksum is calculated.
891:                 	 *                                The checksum will be available using the DmaSfmChecksum function.
892:                 	 *
893:                 	 * Output:          None
894:                 	 *
895:                 	 * Side Effects:    None
896:                 	 *
897:                 	 * Overview:        The function attaches the SFM checksum module to a DMA channel and enables the checksum generator.
898:                 	 *                  From now on, all the DMA traffic is directed to the SFM checksum generator. Once the DMA block transfer
899:                 	 *                  is complete, the checksum result is available in the checksum data register.
900:                 	 *                  If append mode is enabled, no data transfer takes place but the checksum result will be deposited at the DMA destination address.
901:                 
902:                 	 *
903:                 	 * Note:            If append mode is enabled the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
904:                 	 * 
905:                 	 * Example:         DmaSfmAttachChannel(DMA_CHANNEL0, TRUE);
906:                 	 ********************************************************************/
907:                 	void			DmaSfmAttachChannel(DmaChannel chn, int appendMode);
908:                 	#define			CrcAttachChannel	DmaSfmAttachChannel		// PIC32_3xx backward compatibility name	
909:                 
910:                 	/*********************************************************************
911:                 	 * Function:        unsigned int DmaSfmChecksum(void)
912:                 	 *
913:                 	 * PreCondition:    None
914:                 	 *
915:                 	 * Input:			None
916:                 	 *
917:                 	 * Output:          the current value of the checksum generator.
918:                 	 *
919:                 	 * Side Effects:    None
920:                 	 *
921:                 	 * Overview:		The function returns the calculated checksum value.
922:                 	 *
923:                 	 * Note:            - The function returns the valid checksum result. The masking out the unused MSbits in the checksum register is done by the hardware.
924:                 	 *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
925:                 	 *
926:                 	 * Example:         unsigned int myChk=DmaSfmChecksum();
927:                 	 ********************************************************************/
928:                 	extern __inline__ int __attribute__((always_inline)) DmaSfmChecksum(void)
929:                 	{
930:                 		return DCRCDATA;
931:                 	}
932:                 	#define		CrcResult	DmaSfmChecksum		// PIC32_3xx backward compatibility name
933:                 	#define		DmaCrcGetValue	DmaSfmChecksum		// PIC32_3xx backward compatibility name 
934:                 
935:                 
936:                 	/*********************************************************************
937:                 	 * Function:        void DmaSfmSetSeed(unsigned int seed)
938:                 	 *
939:                 	 * PreCondition:    None
940:                 	 *
941:                 	 * Input:           seed	- the initial seed of the checksum generator
942:                 	 *
943:                 	 * Output:          None
944:                 	 *
945:                 	 * Side Effects:    None
946:                 	 *
947:                 	 * Overview:        The function sets the seed of the checksum generator. This is the initial data present in the
948:                 	 *                  CRC shift register or the IP checksum calculator before the actual transfer/calculation begins.
949:                 	 *
950:                 	 * Note:            When the SFM is configured for IP checksum mode, only the least significant 16 bits are relevant.
951:                 	 *
952:                 	 * Example:         DmaSfmSetSeed(0xffffffff);
953:                 	 ********************************************************************/
954:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmSetSeed(unsigned int seed)
955:                 	{
956:                 		DCRCDATA=seed;
957:                 	}
958:                 	#define		DmaCrcSetSeed	DmaSfmSetSeed		// PIC32_3xx backward compatibility name
959:                 
960:                 	 
961:                 /*********************  end of high level functions ****************************************/
962:                 
963:                 	// low level definitions for the API functions
964:                 
965:                 
966:                 	typedef struct
967:                 	{
968:                 		union
969:                 		{
970:                 			struct
971:                 			{
972:                 				unsigned int chn:	3;		// last active DMA channel
973:                 				unsigned int rdOp:	1;		// last DMA operation, read if 1, write if 0
974:                 			};
975:                 			unsigned int	w;						// word access
976:                 		}lastAccess;
977:                 		void*	lastAddress;		// most recent DMA address
978:                 	}DmaStatus;			// DMA controller status
979:                 
980:                 	typedef enum
981:                 	{
982:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
983:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
984:                 		//
985:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_ON		// all flags
986:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
987:                 
988:                 
989:                 
990:                 
991:                 	typedef enum
992:                 	{
993:                 		DMA_EV_ABORT_IRQ_EN =		_DCH0ECON_AIRQEN_MASK,
994:                 		DMA_EV_START_IRQ_EN =		_DCH0ECON_SIRQEN_MASK,
995:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
996:                         // the start and abort IRQ signals
997:                 		DMA_EV_MATCH_EN =			_DCH0ECON_PATEN_MASK,
998:                 
999:                 
1000:                        // compiler use only field
1001:                        _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
1002:                	}DmaEvCtrlFlags;	/*DMA channel event control fields accessible as flags also
1003:                	                	  part of DmaEvCtrlFlags:
1004:                	                	*/
1005:                	#define	DMA_EV_START_IRQ(irq)	(DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
1006:                	#define	DMA_EV_ABORT_IRQ(irq)	(DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
1007:                
1008:                	// DMA channel event control as a structure:
1009:                	#define	DmaEvCtrl	__DCH0ECONbits_t
1010:                
1011:                
1012:                
1013:                
1014:                	typedef enum
1015:                	{
1016:                		DMA_CTL_AUTO_EN =		_DCH0CON_CHAEN_MASK,
1017:                		DMA_CTL_CHAIN_EN =		_DCH0CON_CHCHN_MASK,
1018:                		DMA_CTL_DET_EN =		_DCH0CON_CHAED_MASK,
1019:                		DMA_CTL_CHN_EN =		_DCH0CON_CHEN_MASK,
1020:                		DMA_CTL_CHAIN_DIR =		_DCH0CON_CHCHNS_MASK,
1021:                        // use the DMA_CTL_PRI() below for selecting the DMA
1022:                        // channel priority
1023:                	}DmaChnCtrlFlags;	// controlling the DMA channel with flags
1024:                	// also part of DmaChnCtrlFlags:
1025:                	#define	DMA_CTL_PRI(pri)	((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
1026:                
1027:                	// DMA channel control as a structure:
1028:                	#define	DmaChnCtrl  	__DCH0CONbits_t
1029:                
1030:                	typedef struct
1031:                	{
1032:                		void*	vSrcAdd;		// source of the DMA transfer, virtual
1033:                		void*	vDstAdd;		// destination of the DMA transfer, virtual
1034:                		int	srcSize;		// source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1035:                		int	dstSize;		// destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1036:                		int	cellSize;		// no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
1037:                	}DmaTxferCtrl;		// transfer setting: the transfer source, destination addresses and size, cell size
1038:                
1039:                
1040:                	/********************** low level DMA channel functions *******************************/
1041:                
1042:                
1043:                
1044:                	// Global DMA controller functions
1045:                
1046:                	/*********************************************************************
1047:                	 * Function:        void DmaEnable(int enable)
1048:                	 *
1049:                	 * PreCondition:    None
1050:                	 *
1051:                	 * Input:           enable - boolean to enable/disable the DMA controller
1052:                	 *
1053:                	 * Output:          None
1054:                	 *
1055:                	 * Side Effects:    None
1056:                	 *
1057:                	 * Overview:       The function enables/disables the DMA controller.
1058:                	 *
1059:                	 * Note:           None.
1060:                	 *
1061:                	 * Example:        DmaEnable(1);
1062:                	 ********************************************************************/
1063:                	extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
1064:                	{
1065:                		if(enable)
1066:                		{
1067:                			DMACONSET=_DMACON_ON_MASK;
1068:                		}
1069:                		else
1070:                		{
1071:                			DMACONCLR=_DMACON_ON_MASK;
1072:                			while(DMACONbits.ON);		// wait to take effect
1073:                		}
1074:                	}
1075:                
1076:                	/*********************************************************************
1077:                	 * Function:        void DmaReset(void)
1078:                	 *
1079:                	 * PreCondition:    None
1080:                	 *
1081:                	 * Input:		None
1082:                	 *
1083:                	 * Output:          None
1084:                	 *
1085:                	 * Side Effects:    None
1086:                	 *
1087:                	 * Overview:        The function resets the DMA controller.
1088:                	 *
1089:                	 * Note:            None.
1090:                	 *
1091:                	 * Example:        DmaReset();
1092:                	 ********************************************************************/
1093:                	#define            DmaReset()	DmaEnable(0)
1094:                
1095:                
1096:                	/*********************************************************************
1097:                	 * Function:        int DmaSuspend(void)
1098:                	 *
1099:                	 * PreCondition:    None
1100:                	 *
1101:                	 * Input:		None
1102:                	 *
1103:                	 * Output:          true if the DMA was previously suspended, false otherwise
1104:                	 *
1105:                	 *
1106:                	 * Side Effects:    None
1107:                	 *
1108:                	 * Overview:        The function suspends the DMA controller.
1109:                	 *
1110:                	 * Note:            After the execution of this function the DMA operation is supposed to be suspended.
1111:                	 *                  I.e. the function has to wait for the suspension to take place!
1112:                	 *
1113:                	 * Example:         int susp=DmaSuspend();
1114:                	 ********************************************************************/
1115:                        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
1116:                	{
1117:                		int suspSt;
1118:                		if(!(suspSt=DMACONbits.SUSPEND))
9D0005E8  3C02BF88   LUI V0, -16504
9D0005EC  8C423000   LW V0, 12288(V0)
9D0005F0  7C420300   EXT V0, V0, 12, 1
9D0005F4  304200FF   ANDI V0, V0, 255
9D0005F8  AFC2002C   SW V0, 44(S8)
9D0005FC  8FC2002C   LW V0, 44(S8)
9D000600  14400009   BNE V0, ZERO, 0x9D000628
9D000604  00000000   NOP
9D0006BC  3C02BF88   LUI V0, -16504
9D0006C0  8C423000   LW V0, 12288(V0)
9D0006C4  7C420300   EXT V0, V0, 12, 1
9D0006C8  304200FF   ANDI V0, V0, 255
9D0006CC  AFC20038   SW V0, 56(S8)
9D0006D0  8FC20038   LW V0, 56(S8)
9D0006D4  1440000E   BNE V0, ZERO, 0x9D000710
9D0006D8  00000000   NOP
1119:                		{
1120:                			DMACONSET=_DMACON_SUSPEND_MASK;		// suspend
9D000608  3C02BF88   LUI V0, -16504
9D00060C  24031000   ADDIU V1, ZERO, 4096
9D000610  AC433008   SW V1, 12296(V0)
9D0006DC  3C02BF88   LUI V0, -16504
9D0006E0  24031000   ADDIU V1, ZERO, 4096
9D0006E4  AC433008   SW V1, 12296(V0)
1121:                			while((DMACONbits.DMABUSY));	// wait to be actually suspended
9D000614  3C02BF88   LUI V0, -16504
9D000618  8C423000   LW V0, 12288(V0)
9D00061C  30420800   ANDI V0, V0, 2048
9D000620  1440FFFC   BNE V0, ZERO, 0x9D000614
9D000624  00000000   NOP
9D0006E8  3C02BF88   LUI V0, -16504
9D0006EC  8C423000   LW V0, 12288(V0)
9D0006F0  30420800   ANDI V0, V0, 2048
9D0006F4  1440FFFC   BNE V0, ZERO, 0x9D0006E8
9D0006F8  00000000   NOP
9D0006FC  0B4001C4   J 0x9D000710
9D000700  00000000   NOP
1122:                		}
1123:                		return suspSt;
9D000628  8FC2002C   LW V0, 44(S8)
1124:                	}
1125:                
1126:                
1127:                
1128:                	/*********************************************************************
1129:                	 * Function:        void DmaResume(int susp)
1130:                	 *
1131:                	 * PreCondition:    None
1132:                	 *
1133:                	 * Input:		the desired DMA suspended state.
1134:                	 *
1135:                	 * Output:          None
1136:                	 *
1137:                	 * Side Effects:    None
1138:                	 *
1139:                	 * Overview:		The function restores the DMA controller activity to the old suspended mode.
1140:                	 *
1141:                	 * Note:            None.
1142:                	 *
1143:                	 * Example:			int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1144:                	 ********************************************************************/
1145:                        extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1146:                	{
1147:                		if(susp)
9D0006B0  8FC20034   LW V0, 52(S8)
9D0006B4  10400013   BEQ V0, ZERO, 0x9D000704
9D0006B8  00000000   NOP
1148:                		{
1149:                			DmaSuspend();
1150:                		}
1151:                		else
1152:                		{
1153:                			DMACONCLR=_DMACON_SUSPEND_MASK;		// resume DMA activity
9D000704  3C02BF88   LUI V0, -16504
9D000708  24031000   ADDIU V1, ZERO, 4096
9D00070C  AC433004   SW V1, 12292(V0)
1154:                		}
1155:                	}
1156:                
1157:                	/*********************************************************************
1158:                	 * Function:        void DmaGetStatus(DmaStatus* pStat)
1159:                	 *
1160:                	 * PreCondition:    pStat	- valid pointer
1161:                	 *
1162:                	 * Input:			pStat	- pointer to a DmaStatus structure to store the current DMA controller
1163:                	 * 							status, carrying the following info:
1164:                	 * 								- chn:	the last active DMA channel
1165:                	 * 								- rdOp: the last DMA operation, read/write
1166:                	 * 								- lastAddress: the most recent DMA address
1167:                	 *
1168:                	 * Output:          None
1169:                	 *
1170:                	 * Side Effects:    None
1171:                	 *
1172:                	 * Overview:		The function updates the info for the current DMA controller status.
1173:                	 * 					It updates the last DMA: operation, channel used and address.
1174:                	 *
1175:                	 * Note:            None.
1176:                	 *
1177:                	 * Example:			DmaStatus stat; DmaGetStatus(&stat);
1178:                	 ********************************************************************/
1179:                	 void			DmaGetStatus(DmaStatus* pStat);
1180:                
1181:                	/*********************************************************************
1182:                	 * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1183:                	 *
1184:                	 * PreCondition:    None
1185:                	 *
1186:                	 * Input:           gFlags - flags to be set, having the following fields:
1187:                	 * 			- DMA_GFLG_SUSPEND: DMA controller operation suspend
1188:                	 * 			- DMA_GFLG_ON: DMA controller enabled/desabled
1189:                	 * 			- DMA_GFLG_ALL_FLAGS: all flags
1190:                	 *
1191:                	 * Output:          None
1192:                	 *
1193:                	 * Side Effects:    None
1194:                	 *
1195:                	 * Overview:        The function affects the global behavior of the DMA controller.
1196:                	 *                  It sets the specified flags. Any flag that is set in the gFlags will be
1197:                	 *                  enabled, the other flags won't be touched.
1198:                	 *
1199:                	 * Note:            None.
1200:                	 *
1201:                	 * Example:         DmaSetGlobalFlags(DMA_GFLG_ON);
1202:                	 ********************************************************************/
1203:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1204:                	{
1205:                		DMACONSET=gFlags;
1206:                	}
1207:                
1208:                	/*********************************************************************
1209:                	 * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1210:                	 *
1211:                	 * PreCondition:    None
1212:                	 *
1213:                	 * Input:           gFlags - flags to be cleared, having the following fields:
1214:                	 *                               - DMA_GFLG_SUSPEND: DMA controller operation suspend
1215:                	 *                               - DMA_GFLG_ON: DMA controller enabled/desabled
1216:                	 *                               - DMA_GFLG_ALL_FLAGS: all flags
1217:                	 *
1218:                	 * Output:          None
1219:                	 *
1220:                	 * Side Effects:    None
1221:                	 *
1222:                	 * Overview:        The function affects the global behavior of the DMA controller.
1223:                	 *                  It clears the specified flags. Any flag that is set in the gFlags will be
1224:                	 *                  cleared, the other flags won't be touched.
1225:                	 *
1226:                	 * Note:            None.
1227:                	 *
1228:                	 * Example:         DmaClrGlobalFlags(DMA_GFLG_SUSPEND);
1229:                	 ********************************************************************/
1230:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1231:                	{
1232:                		DMACONCLR=gFlags;
1233:                	}
1234:                
1235:                
1236:                	/*********************************************************************
1237:                	 * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1238:                	 *
1239:                	 * PreCondition:    None
1240:                	 *
1241:                	 * Input:           gFlags - flags to be set, having the following fields:
1242:                	 *                                 - DMA_GFLG_SUSPEND: DMA controller operation suspend
1243:                	 *                                 - DMA_GFLG_ON: DMA controller enabled/desabled
1244:                	 *                                 - DMA_GFLG_ALL_FLAGS: all flags
1245:                	 *
1246:                	 * Output:          None
1247:                	 *
1248:                	 * Side Effects:    None
1249:                	 *
1250:                	 * Overview:        The function affects the global behavior of the DMA controller.
1251:                	 *                  It forces the flags to have the specified gFlags value.
1252:                	 *
1253:                	 * Note:            None.
1254:                	 *
1255:                	 * Example:         DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1256:                	 ********************************************************************/
1257:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1258:                	{
1259:                		DMACON=gFlags;
1260:                	}
1261:                
1262:                	/*********************************************************************
1263:                	 * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1264:                	 *
1265:                	 * PreCondition:    None
1266:                	 *
1267:                	 * Input:           None
1268:                	 *
1269:                	 * Output:          The current DMA controller flags settings.
1270:                	 *                              - DMA_GFLG_SUSPEND: DMA controller operation suspend
1271:                	 *                              - DMA_GFLG_ON: DMA controller enabled/desabled
1272:                	 *
1273:                	 * Side Effects:    None
1274:                	 *
1275:                	 * Overview:        The function returns the global flags of the DMA controller.
1276:                	 *
1277:                	 * Note:            None.
1278:                	 *
1279:                	 * Example:         DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1280:                	 ********************************************************************/
1281:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1282:                	{
1283:                		return (DmaGlblFlags)DMACON;
1284:                	}
1285:                
1286:                
1287:                	/*********************************************************************
1288:                	 * Function:        int DmaGetMaxTxferSize(void)
1289:                	 *
1290:                	 * PreCondition:    None
1291:                	 *
1292:                	 * Input:           None
1293:                	 *
1294:                	 * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1295:                	 *
1296:                	 * Side Effects:    None
1297:                	 *
1298:                	 * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1299:                	 *
1300:                	 * Note:            Revision dependant.
1301:                	 *
1302:                	 * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1303:                	 ********************************************************************/
1304:                	extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1305:                	{
1306:                		return 65536;
1307:                	}
1308:                
1309:                	// Direct Channel control functions
1310:                
1311:                	typedef enum
1312:                	{
1313:                		DMA_CONFIG_DEFAULT = 0,                             // DMA default operation
1314:                		DMA_CONFIG_AUTO	= _DCH0CON_CHAEN_MASK,              // DMA channel is auto enabled
1315:                		DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
1316:                		DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),		// DMA channel is chained to higher channel
1317:                		DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,			// events detection enabled while channel off
1318:                		DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,	            // DMA channel is enabled after open
1319:                		DMA_CONFIG_MATCH	= 0x80000000,                   // DMA channel stops on match
1320:                	}DmaConfigFlags;	// flags for the channel configuration
1321:                
1322:                
1323:                
1324:                	/*********************************************************************
1325:                	 * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1326:                	 *
1327:                	 * PreCondition:    chPri  - valid channel priority, 0-3
1328:                	 *
1329:                	 * Input:           chn    - channel to be configured in the DMA controller
1330:                	 *                  chPri  - the priority given to the channel, 0-3
1331:                	 *                  cFlags - orred flags specifying the configuration:
1332:                	 *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1333:                	 *                           DMA_CONFIG_AUTO:	DMA channel is auto enabled
1334:                	 *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1335:                	 *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1336:                	 *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1337:                	 *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1338:                	 *                           DMA_CONFIG_MATCH:	DMA channel stops on match
1339:                	 *
1340:                	 *
1341:                	 *
1342:                	 * Output:          None
1343:                	 *
1344:                	 * Side Effects:    None
1345:                	 *
1346:                	 * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1347:                	 *
1348:                	 * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1349:                	 *                  The channel is just configured.
1350:                	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1351:                	 *                  if DMA_CONFIG_ENABLE flag was not specified.
1352:                	 *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1353:                	 *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1354:                	 *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1355:                	 *                  User has to call event channel functions to clear/enable the event flags if needed.
1356:                	 *
1357:                	 * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1358:                	 ********************************************************************/
1359:                	void			DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1360:                
1361:                
1362:                	/*********************************************************************
1363:                	 * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1364:                	 *
1365:                	 * PreCondition:    chn	- valid DMA channel
1366:                	 *
1367:                	 * Input:			chn		- DMA channel number
1368:                	 *
1369:                	 * Output:          Current channel source pointer.
1370:                	 *
1371:                	 * Side Effects:    None
1372:                	 *
1373:                	 * Overview:		The function retrieves the current source pointer for the selected DMA channel.
1374:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1375:                	 *
1376:                	 * Note:            None
1377:                	 *
1378:                	 * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL3);
1379:                	 ********************************************************************/
1380:                	 int			DmaChnGetSrcPnt(DmaChannel chn);
1381:                
1382:                	/*********************************************************************
1383:                	 * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1384:                	 *
1385:                	 * PreCondition:    chn	- valid DMA channel
1386:                	 *
1387:                	 * Input:			chn		- DMA channel number
1388:                	 *
1389:                	 * Output:          Current channel destination pointer.
1390:                	 *
1391:                	 * Side Effects:    None
1392:                	 *
1393:                	 * Overview:		The function retrieves the current destination pointer for the selected DMA channel.
1394:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1395:                	 *
1396:                	 * Note:            None
1397:                	 *
1398:                	 * Example:			int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL3);
1399:                	 ********************************************************************/
1400:                	 int			DmaChnGetDstPnt(DmaChannel chn);
1401:                
1402:                	/*********************************************************************
1403:                	 * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1404:                	 *
1405:                	 * PreCondition:    chn	- valid DMA channel
1406:                	 *
1407:                	 * Input:			chn		- DMA channel number
1408:                	 *
1409:                	 * Output:          Current channel transfer pointer.
1410:                	 *
1411:                	 * Side Effects:    None
1412:                	 *
1413:                	 * Overview:		The function retrieves the current transfer progress pointer for the selected DMA channel.
1414:                	 * 					It ranges 0 to DmaGetMaxTxferSize()-1.
1415:                	 *
1416:                	 * Note:            None
1417:                	 *
1418:                	 * Example:			int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL3);
1419:                	 ********************************************************************/
1420:                	 int			DmaChnGetCellPnt(DmaChannel chn);
1421:                
1422:                
1423:                
1424:                	/*********************************************************************
1425:                	 * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1426:                	 *
1427:                	 * PreCondition:    chn	- valid DMA channel
1428:                	 *
1429:                	 * Input:			chn			- DMA channel number
1430:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1431:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1432:                	 * 										- SIRQEN: enable/disable the start IRQ action
1433:                	 * 										- PATEN: enable/disable the pattern match and abort
1434:                	 * 									or any of the DmaEvCtrlFlags:
1435:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1436:                	 *
1437:                	 *
1438:                	 * Output:          None
1439:                	 *
1440:                	 * Side Effects:    None
1441:                	 *
1442:                	 * Overview:		The function sets the events that start and abort the transfer
1443:                	 * 					for the selected DMA channel.
1444:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1445:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1446:                	 *
1447:                	 * Note:            None.
1448:                	 *
1449:                	 * Example:			either:
1450:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1451:                	 * 					or:
1452:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1453:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1454:                	 *
1455:                	 ********************************************************************/
1456:                	 void			DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1457:                
1458:                
1459:                	/*********************************************************************
1460:                	 * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1461:                	 *
1462:                	 * PreCondition:    chn	- valid DMA channel
1463:                	 *
1464:                	 * Input:			chn			- DMA channel number
1465:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1466:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1467:                	 * 										- SIRQEN: enable/disable the start IRQ action
1468:                	 * 										- PATEN: enable/disable the pattern match and abort
1469:                	 * 									or any of the DmaEvCtrlFlags:
1470:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1471:                	 *
1472:                	 *
1473:                	 * Output:          None
1474:                	 *
1475:                	 * Side Effects:    None
1476:                	 *
1477:                	 * Overview:		The function clears the events that start and abort the transfer
1478:                	 * 					for the selected DMA channel.
1479:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1480:                	 * 					disabled for the selected channel, the other channel event flags won't be touched.
1481:                	 *
1482:                	 * Note:            None.
1483:                	 *
1484:                	 * Example:			either:
1485:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1486:                	 * 					or:
1487:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1488:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1489:                	 *
1490:                	 ********************************************************************/
1491:                	 void			DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1492:                
1493:                
1494:                
1495:                	/*********************************************************************
1496:                	 * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1497:                	 *
1498:                	 * PreCondition:    chn	- valid DMA channel
1499:                	 *
1500:                	 * Input:			chn			- DMA channel number
1501:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1502:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1503:                	 * 										- SIRQEN: enable/disable the start IRQ action
1504:                	 * 										- PATEN: enable/disable the pattern match and abort
1505:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1506:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1507:                	 * 									or any of the DmaEvCtrlFlags:
1508:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1509:                	 *
1510:                	 *
1511:                	 * Output:          None
1512:                	 *
1513:                	 * Side Effects:    None
1514:                	 *
1515:                	 * Overview:		The function writes the events that start and abort the transfer
1516:                	 * 					for the selected DMA channel.
1517:                	 *
1518:                	 * Note:            None.
1519:                	 *
1520:                	 * Example:			either:
1521:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1522:                	 * 					or:
1523:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1524:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1525:                	 *
1526:                	 ********************************************************************/
1527:                	 void			DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1528:                
1529:                
1530:                
1531:                	/*********************************************************************
1532:                	 * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1533:                	 *
1534:                	 * PreCondition:    chn	- valid DMA channel
1535:                	 *
1536:                	 * Input:			chn			- DMA channel number
1537:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1538:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1539:                	 * 										- SIRQEN: enable/disable the start IRQ action
1540:                	 * 										- PATEN: enable/disable the pattern match and abort
1541:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1542:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1543:                	 * 									or any of the DmaEvCtrlFlags:
1544:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1545:                	 *
1546:                	 *
1547:                	 * Output:          None
1548:                	 *
1549:                	 * Side Effects:    None
1550:                	 *
1551:                	 * Overview:		The function sets the events that start and abort the transfer
1552:                	 * 					for the selected DMA channel.
1553:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1554:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1555:                	 *
1556:                	 * Note:           A shorter name for DmaChnWriteEventControlFlags();
1557:                	 *
1558:                	 * Example:			either:
1559:                	 * 						DmaChnSetEventControl(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1560:                	 * 					or:
1561:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1562:                	 * 						DmaChnSetEventControl(DMA_CHANNEL3, evCtrl.w);
1563:                	 *
1564:                	 ********************************************************************/
1565:                	#define			DmaChnSetEventControl(chn, dmaEvCtrl)	DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1566:                
1567:                
1568:                	/*********************************************************************
1569:                	 * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1570:                	 *
1571:                	 * PreCondition:    chn	- valid DMA channel
1572:                	 *
1573:                	 * Input:			chn		- DMA channel number
1574:                	 *
1575:                	 * Output:          - 	either a DmaEvCtrl structure field, carrying the following info:
1576:                	 * 							- AIRQEN: enable/disable the abort IRQ action
1577:                	 * 							- SIRQEN: enable/disable the start IRQ action
1578:                	 * 							- PATEN: enable/disable the pattern match and abort
1579:                	 * 							- CHSIRQ: IRQ number to start the DMA channel transfer
1580:                	 * 							- CHAIRQ: IRQ number to abort the DMA channel transfer
1581:                	 * 						or any of the DmaEvCtrlFlags:
1582:                	 * 							DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1583:                	 *
1584:                	 *
1585:                	 * Side Effects:    None
1586:                	 *
1587:                	 * Overview:		The function retrieves the events that start and abort the transfer
1588:                	 * 					for the selected DMA channel.
1589:                	 *
1590:                	 * Note:            None.
1591:                	 *
1592:                	 * Example:			either:
1593:                	 * 						DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1594:                	 * 					or:
1595:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrl.PATEN){...}
1596:                	 *
1597:                	 ********************************************************************/
1598:                	 DmaEvCtrlFlags	DmaChnGetEventControl(DmaChannel chn);
1599:                
1600:                
1601:                	/*********************************************************************
1602:                	 * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1603:                	 *
1604:                	 * PreCondition:    chn	- valid DMA channel
1605:                	 *
1606:                	 * Input:			chn			- DMA channel number
1607:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1608:                	 * 										- autoEn: enable/disable the automatic mode
1609:                	 * 										- chainEn: enable/disable channel chaining
1610:                	 * 										- detectEn: enable/disable events detection when channel disabled
1611:                	 * 										- chEn: enable/disable channel functionality
1612:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1613:                	 * 									or any of the DmaChnCtrlFlags flags:
1614:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1615:                	 *
1616:                	 * Output:          None
1617:                	 *
1618:                	 * Side Effects:    None
1619:                	 *
1620:                	 * Overview:		The function sets the selected DMA channel control flags:
1621:                	 * 					the chaining or auto mode, and events detection.
1622:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1623:                	 * 					set for the selected channel, the other channel control flags won't be touched.
1624:                	 *
1625:                	 * Note:            None.
1626:                	 *
1627:                	 * Example:			either:
1628:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1629:                	 * 					or:
1630:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1631:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL3, chCtrl.w);
1632:                	 *
1633:                	 ********************************************************************/
1634:                	 void			DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1635:                
1636:                	/*********************************************************************
1637:                	 * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1638:                	 *
1639:                	 * PreCondition:    chn	- valid DMA channel
1640:                	 *
1641:                	 * Input:			chn			- DMA channel number
1642:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1643:                	 * 										- autoEn: enable/disable the automatic mode
1644:                	 * 										- chainEn: enable/disable channel chaining
1645:                	 * 										- detectEn: enable/disable events detection when channel disabled
1646:                	 * 										- chEn: enable/disable channel functionality
1647:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1648:                	 * 									or any of the DmaChnCtrlFlags flags:
1649:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1650:                	 *
1651:                	 * Output:          None
1652:                	 *
1653:                	 * Side Effects:    None
1654:                	 *
1655:                	 * Overview:		The function clears the selected DMA channel control flags:
1656:                	 * 					the chaining or auto mode and events detection.
1657:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1658:                	 * 					cleared for the selected channel, the other channel control flags won't be touched.
1659:                	 *
1660:                	 * Note:            None.
1661:                	 *
1662:                	 * Example:			either:
1663:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1664:                	 * 					or:
1665:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1666:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL3, chCtrl.w);
1667:                	 *
1668:                	 ********************************************************************/
1669:                	 void			DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1670:                
1671:                	/*********************************************************************
1672:                	 * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1673:                	 *
1674:                	 * PreCondition:    chn	- valid DMA channel
1675:                	 *
1676:                	 * Input:			chn			- DMA channel number
1677:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1678:                	 * 										- chPri: channel priority 0-3
1679:                	 * 										- autoEn: enable/disable the automatic mode
1680:                	 * 										- chainEn: enable/disable channel chaining
1681:                	 * 										- detectEn: enable/disable events detection when channel disabled
1682:                	 * 										- chEn: enable/disable channel functionality
1683:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1684:                	 * 									or any of the DmaChnCtrlFlags flags:
1685:                	 * 										DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1686:                	 *
1687:                	 * Output:          None
1688:                	 *
1689:                	 * Side Effects:    None
1690:                	 *
1691:                	 * Overview:		The function enables/disables the selected DMA channel and also sets
1692:                	 * 					the channel priority, chaining mode or auto and events detection.
1693:                	 *
1694:                	 * Note:            None.
1695:                	 *
1696:                	 * Example:			either:
1697:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1698:                	 * 					or:
1699:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1700:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL3, chCtrl.w);
1701:                	 *
1702:                	 ********************************************************************/
1703:                	 void			DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1704:                
1705:                	/*********************************************************************
1706:                	 * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1707:                	 *
1708:                	 * PreCondition:    chn	- valid DMA channel
1709:                	 *
1710:                	 * Input:	    chn		- DMA channel number
1711:                	 *                  dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1712:                	 * 						- chPri: channel priority 0-3
1713:                	 * 						- autoEn: enable/disable the automatic mode
1714:                	 * 						- chainEn: enable/disable channel chaining
1715:                	 * 						- detectEn: enable/disable events detection when channel disabled
1716:                	 * 						- chEn: enable/disable channel functionality
1717:                	 * 						- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1718:                	 * 					or any of the DmaChnCtrlFlags flags:
1719:                	 * 						DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1720:                	 *
1721:                	 * Output:          None
1722:                	 *
1723:                	 * Side Effects:    None
1724:                	 *
1725:                	 * Overview:        The function enables/disables the selected DMA channel and also sets
1726:                	 * 					the channel priority, chaining mode or auto and events detection.
1727:                	 *
1728:                	 * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1729:                	 *
1730:                	 * Example:         either:
1731:                	 *                      DmaChnSetControl(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1732:                	 *                  or:
1733:                	 *                     	DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1734:                	 * 			DmaChnSetControl(DMA_CHANNEL3, chCtrl.w);
1735:                	 *
1736:                	 ********************************************************************/
1737:                	#define		DmaChnSetControl(chn, dmaChnCtrl)	DmaChnWriteControlFlags(chn, dmaChnCtrl)
1738:                
1739:                	/*********************************************************************
1740:                	 * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1741:                	 *
1742:                	 * PreCondition:    chn	- valid DMA channel
1743:                	 *
1744:                	 * Input:			chn			- DMA channel number
1745:                	 *
1746:                	 * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1747:                	 * 							- chPri: channel priority 0-3
1748:                	 * 							- autoEn: enable/disable the automatic mode
1749:                	 * 							- chainEn: enable/disable channel chaining
1750:                	 * 							- detectEn: enable/disable events detection when channel disabled
1751:                	 * 							- chEn: enable/disable channel functionality
1752:                	 * 							- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1753:                	 *						or any of the DmaChnCtrlFlags flags:
1754:                	 *							DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1755:                	 *
1756:                	 * Side Effects:    None
1757:                	 *
1758:                	 * Overview:		The function retrieves the current control settings for the selected DMA channel,
1759:                	 * 					including the channel enable/disable status, the channel priority,
1760:                	 * 					chaining mode, auto mode and events detection.
1761:                	 *
1762:                	 * Note:            None.
1763:                	 *
1764:                	 * Example:			either:
1765:                	 * 						DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL3); if(ctrl&DMA_CTL_AUTO_EN) {...}
1766:                	 * 					or:
1767:                	 * 						DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL3); if(chnCtrl.autoEn) {...}
1768:                	 *
1769:                	 ********************************************************************/
1770:                	 DmaChnCtrlFlags	DmaChnGetControlFlags(DmaChannel chn);
1771:                
1772:                
1773:                	/*********************************************************************
1774:                	 * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1775:                	 *
1776:                	 * PreCondition:    chn	- valid DMA channel
1777:                	 *
1778:                	 * Input:			chn		- DMA channel number
1779:                	 *
1780:                	 * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1781:                	 *
1782:                	 * Side Effects:    None
1783:                	 *
1784:                	 * Overview:		The function returns the current event detection for the selected DMA channel.
1785:                	 *
1786:                	 * Note:            None.
1787:                	 *
1788:                	 * Example:			int evDetect=DmaChnGetEvDetect(DMA_CHANNEL3);
1789:                	 *
1790:                	 ********************************************************************/
1791:                	 int			DmaChnGetEvDetect(DmaChannel chn);
1792:                
1793:                	/*********************************************************************
1794:                	 * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1795:                	 *
1796:                	 * PreCondition:    chn		- valid DMA channel
1797:                	 * 					pTxCtrl	- valid pointer
1798:                	 *
1799:                	 * Input:			chn			- DMA channel number
1800:                	 * 					pTxCtrl		- pointer to a DmaTxferCtrl that will carry the following info:
1801:                	 * 								- vSrcAdd: source of the DMA transfer
1802:                	 * 								- vDstAdd: destination of the DMA transfer
1803:                	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1804:                	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1805:                	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1806:                	 *					mapToK0		- if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1807:                	 *
1808:                	 * Output:          None
1809:                	 *
1810:                	 * Side Effects:    None
1811:                	 *
1812:                	 * Overview:		The function retrieves the transfer characteristics for a DMA channel transfer:
1813:                	 * 					the source and the destination addresses.
1814:                	 * 					It also retrieves the source and destination lengths
1815:                	 * 					and the number of bytes	transferred per event.
1816:                	 *
1817:                	 * Note:            None
1818:                	 *
1819:                	 * Example:			DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL3, &txCtl, FALSE);
1820:                	 ********************************************************************/
1821:                	 void			DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1822:                
1823:                	// Low level checksum functions
1824:                
1825:                	/*********************************************************************
1826:                	 * Function:        void DmaSfmEnable(int enable)
1827:                	 *
1828:                	 * PreCondition:    None
1829:                	 *
1830:                	 * Input:           enable _ boolean to enable/disable the SFM functionality
1831:                	 *
1832:                	 * Output:          None
1833:                	 *
1834:                	 * Side Effects:    None
1835:                	 *
1836:                	 * Overview:        The function enables/diables the checksum module functionality.
1837:                	 *                  When enabled the attached DMA channel transfers are routed to the SFM module.
1838:                	 *
1839:                	 * Note:            The SFM module should be properly configured before enabled.
1840:                	 *
1841:                	 * Example:         DmaSfmEnable(1);
1842:                	 ********************************************************************/
1843:                	extern __inline__ void __attribute__((always_inline)) DmaSfmEnable(int enable)
1844:                	{
1845:                		if(enable)
1846:                		{
1847:                			DCRCCONSET=_DCRCCON_CRCEN_MASK;
1848:                		}
1849:                		else
1850:                		{
1851:                			DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1852:                		}
1853:                	}
1854:                	#define DmaCrcEnable	DmaSfmEnable		// PIC32_3xx backward compatibility
1855:                
1856:                
1857:                	/*********************************************************************
1858:                	 * Function:        int DmaSfmGetEnable(void)
1859:                	 *
1860:                	 * PreCondition:    None
1861:                	 *
1862:                	 * Input:			None
1863:                	 *
1864:                	 * Output:          TRUE, if the SFM module is enabled
1865:                	 * 		    FALSE otherwise
1866:                	 *
1867:                	 * Side Effects:    None
1868:                	 *
1869:                	 * Overview:		The function returns the SFM module enabling status.
1870:                	 *
1871:                	 * Note:            None
1872:                	 *
1873:                	 * Example:	    int isSfmEnabled=DmaSfmGetEnable();
1874:                	 ********************************************************************/
1875:                	extern __inline__ int __attribute__((always_inline)) DmaSfmGetEnable(void)
1876:                	{
1877:                		return DCRCCONbits.CRCEN!=0;
1878:                	}
1879:                	#define		DmaCrcGetEnable 	DmaSfmGetEnable		// PIC32_3xx backward compatibility
1880:                
1881:                
1882:                	/*********************************************************************
1883:                	 * Function:        void DmaSfmAppendEnable(int enable)
1884:                	 *
1885:                	 * PreCondition:    None
1886:                	 *
1887:                	 * Input:           enable _ boolean to enable/disable the SFM append mode
1888:                	 *
1889:                	 * Output:          None
1890:                	 *
1891:                	 * Side Effects:    None
1892:                	 *
1893:                	 * Overview:        The function enables the SFM append mode. In this mode, the attached DMA channel reads
1894:                	 *                  the source data but does not write it to the destination address. The data it's just passed
1895:                	 *                  to the checksum generator for CRC/IP checksum calculation.
1896:                	 *                  When the block transfer is completed, the checksum result is written to the
1897:                	 *                  DMA channel destination address.
1898:                	 *
1899:                	 * Note:            The SFM module should be properly configured before enabled.
1900:                	 *
1901:                	 * Example:         DmaSfmAppendModeEnable(TRUE);
1902:                	 ********************************************************************/
1903:                	extern __inline__ void __attribute__((always_inline)) DmaSfmAppendEnable(int enable)
1904:                	{
1905:                		if(enable)
1906:                		{
1907:                			DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1908:                		}
1909:                		else
1910:                		{
1911:                			DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1912:                		}
1913:                	}
1914:                	#define		DmaCrcAppendModeEnable	DmaSfmAppendEnable	// PIC32_3xx backward compatibility
1915:                
1916:                
1917:                	/*********************************************************************
1918:                	 * Function:        int DmaSfmGetAppendMode(void)
1919:                	 *
1920:                	 * PreCondition:    None
1921:                	 *
1922:                	 * Input:           None
1923:                	 *
1924:                	 * Output:          TRUE, if the SFM append mode is enabled
1925:                	 *                  FALSE otherwise
1926:                	 *
1927:                	 * Side Effects:    None
1928:                	 *
1929:                	 * Overview:        The function returns the SFM module enabling status.
1930:                	 *
1931:                	 * Note:            None
1932:                	 *
1933:                	 * Example:         int isAppendEnabled=DmaSfmGetAppendMode();
1934:                	 ********************************************************************/
1935:                	extern __inline__ int __attribute__((always_inline)) DmaSfmGetAppendMode(void)
1936:                	{
1937:                		return DCRCCONbits.CRCAPP!=0;
1938:                	}
1939:                	#define	DmaCrcGetAppendMode	DmaSfmGetAppendMode		// PIC32_3xx backward compatibility
1940:                
1941:                
1942:                	/*********************************************************************
1943:                	 * Function:        void DmaSfmSetAttach(DmaChannel chn)
1944:                	 *
1945:                	 * PreCondition:    chn		- valid DMA channel
1946:                	 *
1947:                	 * Input:           chn	- the DMA channel to be attached to the SFM module (the DMA channel transfers will be routed to the SFM module)
1948:                	 *
1949:                	 * Output:          None
1950:                	 *
1951:                	 * Side Effects:    None
1952:                	 *
1953:                	 * Overview:        The function directly attaches a DMA channel to the SFM module.
1954:                	 *
1955:                	 * Note:            None
1956:                	 *
1957:                	 * Example:         DmaSfmSetAttach(DMA_CHANNEL3);
1958:                	 ********************************************************************/
1959:                	extern __inline__ void __attribute__((always_inline)) DmaSfmSetAttach(DmaChannel chn)
1960:                	{
1961:                		DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1962:                		DCRCCONSET=chn;
1963:                	}
1964:                	#define		DmaCrcSetAttach		DmaSfmSetAttach		// PIC32_3xx backward compatibility
1965:                
1966:                
1967:                	/*********************************************************************
1968:                	 * Function:        DmaChannel DmaSfmGetAttach(void)
1969:                	 *
1970:                	 * PreCondition:    None
1971:                	 *
1972:                	 * Input:           None
1973:                	 *
1974:                	 * Output:          the DMA channel that is currently attached to the CRC module
1975:                	 *
1976:                	 * Side Effects:    None
1977:                	 *
1978:                	 * Overview:        The function returns the DMA channel number that is currently attached to the SFM module.
1979:                	 *
1980:                	 * Note:            None
1981:                	 *
1982:                	 * Example:         DmaChannel chn=DmaSfmGetAttach();
1983:                	 ********************************************************************/
1984:                	extern __inline__ DmaChannel __attribute__((always_inline)) DmaSfmGetAttach(void)
1985:                	{
1986:                		return (DmaChannel)DCRCCONbits.CRCCH;
1987:                	}
1988:                	#define		DmaCrcGetAttach		DmaSfmGetAttach		// PIC32_3xx backward compatibility
1989:                
1990:                	/*********************************************************************
1991:                	 * Function:        void DmaCrcSetPLen(int pLen)
1992:                	 *
1993:                	 * PreCondition:    pLen - valid polynomial length within 1-32
1994:                	 *
1995:                	 * Input:           pLen	- the length of the CRC generator polynomial
1996:                	 *
1997:                	 * Output:          None
1998:                	 *
1999:                	 * Side Effects:    None
2000:                	 *
2001:                	 * Overview:        The length of the CRC generator polynomial is set as being pLen;
2002:                	 *
2003:                	 * Note:            None
2004:                	 *
2005:                	 * Example:         DmaCrcSetPLen(32);
2006:                	 ********************************************************************/
2007:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
2008:                	{
2009:                		DCRCCONCLR=_DCRCCON_PLEN_MASK;
2010:                		DCRCCONSET=(pLen)-1;
2011:                	}
2012:                
2013:                	/*********************************************************************
2014:                	 * Function:        int DmaCrcGetPLen(void)
2015:                	 *
2016:                	 * PreCondition:    None
2017:                	 *
2018:                	 * Input:           None
2019:                	 *
2020:                	 * Output:          the length of the CRC generator polynomial
2021:                	 *
2022:                	 * Side Effects:    None
2023:                	 *
2024:                	 * Overview:        The function returns the current length of the CRC generator polynomial.
2025:                	 *                  It's always a number between 1 and 32.
2026:                	 *
2027:                	 * Note:            None
2028:                	 *
2029:                	 * Example:         int polyLen=DmaCrcGetPLen();
2030:                	 ********************************************************************/
2031:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
2032:                	{
2033:                		return	DCRCCONbits.PLEN+1; 
2034:                	}
2035:                
2036:                	/*********************************************************************
2037:                	 * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
2038:                	 *
2039:                	 * PreCondition:    None
2040:                	 *
2041:                	 * Input:           feedback - the layout of the CRC generator
2042:                	 *
2043:                	 * Output:          None
2044:                	 *
2045:                	 * Side Effects:    None
2046:                	 *
2047:                	 * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
2048:                	 *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2049:                	 *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2050:                	 *
2051:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2052:                	 *
2053:                	 * Example:         DmaCrcSetShiftFeedback(0x04c11db7);
2054:                	 ********************************************************************/
2055:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
2056:                	{
2057:                		DCRCXOR=feedback;
2058:                	}
2059:                
2060:                
2061:                	/*********************************************************************
2062:                	 * Function:        unsigned int DmaCrcGetShiftFeedback(void)
2063:                	 *
2064:                	 * PreCondition:    None
2065:                	 *
2066:                	 * Input:           None
2067:                	 *
2068:                	 * Output:          the current layout of the CRC generator
2069:                	 *
2070:                	 * Side Effects:    None
2071:                	 *
2072:                	 * Overview:        The function returns the layout of the shift stages that take place in the CRC generation.
2073:                	 *                  A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2074:                	 *                  If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2075:                	 *
2076:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2077:                	 *
2078:                	 * Example:         int feedback=DmaCrcGetShiftFeedback();
2079:                	 ********************************************************************/
2080:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
2081:                	{
2082:                		return DCRCXOR;
2083:                	}
2084:                
2085:                
2086:                
2087:                	// Channel test/debug and special functions
2088:                
2089:                	/*********************************************************************
2090:                	 * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2091:                	 *
2092:                	 * PreCondition:    chn	- valid DMA channel
2093:                	 *
2094:                	 * Input:			chn		- DMA channel number
2095:                	 * 					eFlags	- event flags with the following significance:
2096:                	 * 								- DMA_EV_ERR: address error event
2097:                	 * 								- DMA_EV_ABORT: transfer abort event
2098:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2099:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2100:                	 * 								- DMA_EV_DST_HALF: destination half event
2101:                	 * 								- DMA_EV_DST_FULL: destination full event
2102:                	 * 								- DMA_EV_SRC_HALF: source half event
2103:                	 * 								- DMA_EV_SRC_FULL: source full event
2104:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2105:                	 *
2106:                	 * Output:          None
2107:                	 *
2108:                	 * Side Effects:    None
2109:                	 *
2110:                	 * Overview:		The function sets the event flags for the selected DMA channel.
2111:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2112:                	 * 					set for the selected channel, the other channel event flags won't be touched.
2113:                	 *
2114:                	 * Note:            This is intended as a channel test function.
2115:                	 *
2116:                	 * Example:			DmaChnSetEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2117:                	 ********************************************************************/
2118:                	 void			DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2119:                
2120:                	/*********************************************************************
2121:                	 * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2122:                	 *
2123:                	 * PreCondition:    chn	- valid DMA channel
2124:                	 *
2125:                	 * Input:			chn		- DMA channel number
2126:                	 * 					eFlags	- event flags with the following significance:
2127:                	 * 								- DMA_EV_ERR: address error event
2128:                	 * 								- DMA_EV_ABORT: transfer abort event
2129:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2130:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2131:                	 * 								- DMA_EV_DST_HALF: destination half event
2132:                	 * 								- DMA_EV_DST_FULL: destination full event
2133:                	 * 								- DMA_EV_SRC_HALF: source half event
2134:                	 * 								- DMA_EV_SRC_FULL: source full event
2135:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2136:                	 *
2137:                	 * Output:          None
2138:                	 *
2139:                	 * Side Effects:    None
2140:                	 *
2141:                	 * Overview:		The function writes the event flags for the selected DMA channel.
2142:                	 * 					The channel event flags are forced to the eFlags value.
2143:                	 *
2144:                	 * Note:            This is intended as a channel test function.
2145:                	 *
2146:                	 * Example:			DmaChnWriteEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2147:                	 ********************************************************************/
2148:                	 void			DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2149:                
2150:                
2151:                	/********************************************************************
2152:                	 * Include legacy DMA functions
2153:                	 * New projects should not use them!
2154:                	 * Note that interrupt functions are no longer provided.
2155:                	 * The functions in the int.h should be used instead.
2156:                	 ********************************************************************/
2157:                	#ifndef _PLIB_DISABLE_LEGACY
2158:                		#include <peripheral/legacy/dma_legacy.h>
2159:                	#endif
2160:                
2161:                
2162:                #else
2163:                	#undef _DMA_CHANNELS		// no DMA channels
2164:                #endif	// _DMAC0
2165:                
2166:                #endif /*_DMA_H_*/
2167:                
2168:                
